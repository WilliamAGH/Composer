<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
    th:replace="~{layout :: layout(~{::body/content}, 'ComposerAI - Email Chat Interface', ~{::head/extraHead})}">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ComposerAI - Email Chat Interface</title>
    <th:block th:fragment="extraHead">
        <link rel="stylesheet" href="/css/chat.css">
    </th:block>
</head>

<body>
    <div th:fragment="content" class="min-h-screen flex flex-col bg-slate-100/80">
        <nav class="app-nav px-4 py-3.5 sm:px-6">
            <a href="/chat" class="group mx-auto flex max-w-5xl items-center gap-3.5" aria-label="Start a new ComposerAI chat">
                <div class="relative flex h-10 w-10 items-center justify-center rounded-xl bg-gradient-to-br from-slate-900 to-slate-800 shadow-lg shadow-slate-900/25 ring-1 ring-slate-900/10 transition-transform group-hover:scale-[1.03]">
                    <svg class="h-5 w-5 text-white" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                        <path d="M3 8L10.89 13.26C11.2187 13.4793 11.6049 13.5963 12 13.5963C12.3951 13.5963 12.7813 13.4793 13.11 13.26L21 8M5 19H19C19.5304 19 20.0391 18.7893 20.4142 18.4142C20.7893 18.0391 21 17.5304 21 17V7C21 6.46957 20.7893 5.96086 20.4142 5.58579C20.0391 5.21071 19.5304 5 19 5H5C4.46957 5 3.96086 5.21071 3.58579 5.58579C3.21071 5.96086 3 6.46957 3 7V17C3 17.5304 3.21071 18.0391 3.58579 18.4142C3.96086 18.7893 4.46957 19 5 19Z" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="17" cy="7" r="2.5" fill="#10b981" stroke="white" stroke-width="1.5"/>
                    </svg>
                    <div class="pointer-events-none absolute -inset-0.5 -z-10 rounded-xl bg-gradient-to-br from-slate-900 to-slate-800 opacity-0 blur-sm transition group-hover:opacity-60"></div>
                </div>
                <div class="flex flex-col">
                    <span class="text-sm font-bold tracking-tight text-slate-900">ComposerAI</span>
                    <span class="text-[11px] font-medium tracking-wide text-slate-500">Email Intelligence Platform</span>
                </div>
            </a>
        </nav>

        <main class="flex-1 flex">
            <div class="mx-auto flex max-w-5xl flex-1 flex-col px-4 pb-6 pt-6 sm:px-6 lg:px-8">
                <section class="chat-shell flex-1 flex flex-col">
                    <div id="messages"
                        class="flex flex-1 flex-col gap-2.5 px-4 py-4 overflow-y-auto bg-slate-50 sm:px-5 sm:py-5">
                        <div class="message-block w-full">
                            <div class="assistant-surface">
                                <div class="chat-markdown">
                                    <p>Hello! I'm ComposerAI. Upload a file using the icon below and I'll help you analyze and discuss it.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="chat-input border-t border-slate-200 px-4 py-4 sm:px-5">
                        <div id="uploadStatus" class="upload-status hidden"></div>
                        <div class="mb-3 flex flex-wrap items-center gap-3 text-xs sm:text-sm text-slate-600">
                            <div id="thinkingDropdown">
                                <button id="thinkingMenuButton" type="button" aria-haspopup="listbox" aria-expanded="false"
                                    class="inline-flex items-center justify-between gap-2 rounded-xl border border-slate-300 bg-white px-3 py-1 font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50">
                                    <span id="thinkingMenuLabel">Thinking: Off</span>
                                    <svg class="h-3 w-3 text-slate-500 transition-transform" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <button id="jsonToggleButton" type="button"
                                class="rounded-xl border border-slate-300 bg-white px-3 py-1 font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50">JSON
                                Output: Off</button>
                            <div id="thinkingMenu"
                                class="thinking-dropdown-menu fixed z-[9999] w-64 rounded-xl border border-slate-200 bg-white p-1 shadow-xl ring-1 ring-black/5 hidden"
                                aria-labelledby="thinkingMenuButton">
                                <div role="menu">
                                    <button type="button" role="menuitem" data-value="off"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm font-medium text-slate-700 hover:bg-slate-50">Off</button>
                                    <div class="my-1 border-t border-slate-200"></div>
                                    <button type="button" role="menuitem" data-value="minimal"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Minimal</button>
                                    <button type="button" role="menuitem" data-value="low"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Low</button>
                                    <button type="button" role="menuitem" data-value="medium"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Medium</button>
                                    <button type="button" role="menuitem" data-value="high"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">High</button>
                                </div>
                            </div>
                            <span id="thinkingStatus" class="hidden text-slate-500"></span>
                        </div>
                        <div class="flex items-center gap-3">
                            <label id="inlineUploadButton"
                                class="flex h-11 w-11 cursor-pointer items-center justify-center rounded-2xl border border-slate-300 bg-white text-slate-600 shadow-sm transition hover:border-slate-400 hover:text-slate-900 focus-within:outline-none focus-within:ring-2 focus-within:ring-slate-200"
                                title="Upload email or file for context" aria-label="Upload email or file for context">
                                <svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6"
                                    stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                    <path d="M4 12l1.5 1.5a2 2 0 002.828 0L12 9.828a2 2 0 012.828 0L20 15" />
                                    <path d="M3 7l9-4 9 4" />
                                    <path d="M21 10v8a2 2 0 01-2 2H5a2 2 0 01-2-2v-8" />
                                </svg>
                                <input type="file" id="inlineFileInput" class="sr-only" accept=".eml,.msg,.txt,.html,.pdf,.doc,.docx" />
                            </label>
                            <textarea id="messageInput"
                                class="flex-1 resize-none rounded-2xl border border-slate-300 px-4 py-3 text-sm focus:border-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-200"
                                placeholder="Type your message about the email..." rows="1" disabled></textarea>
                            <button id="sendButton"
                                class="flex h-10 w-10 items-center justify-center rounded-full bg-slate-900 text-white transition-all hover:bg-slate-700 disabled:bg-slate-300 disabled:cursor-not-allowed"
                                disabled>
                                <span class="text-xl">&rarr;</span>
                            </button>
                        </div>
                    </div>
                </section>
            </div>
        </main>

        <script th:inline="javascript">
            // Auto-generated from backend Java enums - single source of truth
            // See: GlobalModelAttributes.java â†’ SseEventType.java, ReasoningStreamAdapter.Phase
            const SSE_EVENTS = /*[[${sseEvents}]]*/ {};
            Object.freeze(SSE_EVENTS);

            const REASONING_PHASES = /*[[${reasoningPhases}]]*/ {};
            Object.freeze(REASONING_PHASES);

            const UI_NONCE = /*[[${uiNonce}]]*/ null;

            class SSEEventRouter {
                constructor() {
                    this.handlers = new Map();
                }

                on(eventType, handler) {
                    if (typeof handler === 'function') {
                        this.handlers.set(eventType, handler);
                    }
                    return this;
                }

                route(eventType, data) {
                    const handler = this.handlers.get(eventType);
                    if (handler) handler(data);
                }
            }

            class ComposerAIChat {
                constructor() {
                    this.messages = document.getElementById('messages');
                    this.messageInput = document.getElementById('messageInput');
                    this.sendButton = document.getElementById('sendButton');
                    this.fileDropArea = document.getElementById('fileDropArea');
                    this.fileInput = document.getElementById('fileInput') || document.getElementById('inlineFileInput');
                    this.uploadStatus = document.getElementById('uploadStatus');
                    this.currentEmailContext = null;
                    this.conversationId = null;
                    this.activeStreamController = null;
                    this.isStreaming = false;
                    this.streamState = { thinking: { active: false, phase: 'idle', lastType: null, message: null } };
                    this.thinkingStatus = document.getElementById('thinkingStatus');
                    this.thinkingEnabled = false;
                    this.thinkingLevel = 'medium';
                    this.jsonToggleButton = document.getElementById('jsonToggleButton');
                    this.jsonOutput = false;
                    this.jsonPreClass = 'w-full whitespace-pre-wrap font-mono text-sm leading-relaxed bg-slate-900/90 text-slate-100 rounded-2xl border border-slate-800 p-4 shadow-ultra overflow-x-auto';
                    this.previewCounter = 0;
                    this.streamTimeoutMs = 120000; // Default 2 minutes, updated from server
                    this.maxEmailContextChars = 20000;
                    this.defaultMaxResults = 5;
                    this.insightsTrigger = '__INSIGHTS_TRIGGER__';
                    this.applyMarkdownEnhancements = this.applyMarkdownEnhancements.bind(this);
                    this.initializeEventListeners();
                    this.applyMarkdownEnhancements(this.messages);
                }

                initializeEventListeners() {
                    this.sendButton?.addEventListener('click', () => this.sendMessage());
                    this.messageInput?.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });

                    if (this.fileInput && window.ComposerAI?.FileUploadHandler) {
                        new window.ComposerAI.FileUploadHandler({
                            dropArea: this.fileDropArea || document.getElementById('inlineUploadButton'),
                            fileInput: this.fileInput,
                            onFileSelected: (file) => this.handleFileUpload(file),
                            validExtensions: ['.eml', '.msg', '.txt']
                        });
                    }

                    this.initializeThinkingDropdown();
                    this.initializeJsonToggle();
                    this.updateThinkingControls();
                    this.resetReasoningState();
                }

                initializeThinkingDropdown() {
                    const btn = document.getElementById('thinkingMenuButton');
                    const menu = document.getElementById('thinkingMenu');
                    const label = document.getElementById('thinkingMenuLabel');
                    if (!btn || !menu) return;

                    const setOpen = (open) => {
                        if (open) {
                            const rect = btn.getBoundingClientRect();
                            const spaceBelow = window.innerHeight - rect.bottom;
                            const menuHeight = 240;
                            if (spaceBelow >= menuHeight || spaceBelow > rect.top) {
                                menu.style.top = rect.bottom + 8 + 'px';
                                menu.style.bottom = 'auto';
                            } else {
                                menu.style.bottom = window.innerHeight - rect.top + 8 + 'px';
                                menu.style.top = 'auto';
                            }
                            menu.style.left = rect.left + 'px';
                            menu.classList.remove('hidden');
                        } else {
                            menu.classList.add('hidden');
                        }
                        btn.setAttribute('aria-expanded', String(open));
                        btn.querySelector('svg').style.transform = open ? 'rotate(180deg)' : 'rotate(0)';
                    };

                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        setOpen(btn.getAttribute('aria-expanded') !== 'true');
                    });
                    document.addEventListener('click', (e) => {
                        if (!menu.contains(e.target) && !btn.contains(e.target)) setOpen(false);
                    });
                    window.addEventListener('resize', () => {
                        if (btn.getAttribute('aria-expanded') === 'true') setOpen(true);
                    });

                    menu.querySelectorAll('button[data-value]').forEach(opt => {
                        opt.addEventListener('click', () => {
                            this.updateThinkingMode(opt.getAttribute('data-value'));
                            menu.querySelectorAll('button').forEach(b => b.classList.remove('bg-slate-100'));
                            opt.classList.add('bg-slate-100');
                            setOpen(false);
                        });
                    });

                    this.refreshThinkingMenuLabel = () => {
                        if (label) label.textContent = this.thinkingEnabled ?
                            'Thinking: ' + this.thinkingLevel.charAt(0).toUpperCase() + this.thinkingLevel.slice(1) :
                            'Thinking: Off';
                    };
                    this.refreshThinkingMenuLabel();
                }

                initializeJsonToggle() {
                    if (!this.jsonToggleButton) return;
                    this.jsonToggleButton.addEventListener('click', () => {
                        this.jsonOutput = !this.jsonOutput;
                        this.updateJsonToggleButton();
                        if (!this.thinkingEnabled) {
                            this.resetReasoningState();
                        }
                    });
                    this.updateJsonToggleButton();
                }

                updateJsonToggleState() {
                    if (!this.jsonToggleButton) return;
                    this.updateJsonToggleButton();
                }

                updateJsonToggleButton() {
                    if (!this.jsonToggleButton) return;
                    const isOn = !!this.jsonOutput;
                    this.jsonToggleButton.textContent = isOn ? 'JSON Output: On' : 'JSON Output: Off';
                    const add = (cls) => this.jsonToggleButton.classList.add(cls);
                    const remove = (cls) => this.jsonToggleButton.classList.remove(cls);
                    if (isOn) {
                        add('bg-slate-900');
                        add('text-white');
                        add('border-slate-900');
                        remove('bg-white');
                        remove('text-slate-700');
                        remove('border-slate-300');
                    } else {
                        remove('bg-slate-900');
                        remove('text-white');
                        remove('border-slate-900');
                        add('bg-white');
                        add('text-slate-700');
                        add('border-slate-300');
                    }
                }

                async handleFileUpload(file) {
                    this.showUploadStatus('<div class="upload-status upload-status--info">Uploading and parsing file...</div>');

                    try {
                        const result = await window.ComposerAI.parseEmailFile(file, UI_NONCE);
                        if (!result.contextId) {
                            throw new Error('Server did not provide a contextId for the uploaded file');
                        }
                        this.currentEmailContext = result;
                        this.showUploadStatus('<div class="upload-status upload-status--success">Context uploaded and parsed successfully!</div>');
                        this.enableChat();
                        this.addEmailContextMessage(result);
                    } catch (error) {
                        this.showUploadStatus('<div class="upload-status upload-status--error">Failed to upload file: ' + window.ComposerAI.escapeHtml(String(error?.message || 'Unknown error')) + '</div>');
                    }
                    this.enableChat();
                }

                showUploadStatus(html) {
                    if (!this.uploadStatus) return;
                    this.uploadStatus.innerHTML = html;
                    this.uploadStatus.classList.toggle('hidden', !html);
                }

                getFriendlyFileType(filename) {
                    const lower = filename.toLowerCase();
                    if (lower.endsWith('.eml')) return 'Email (.eml)';
                    if (lower.endsWith('.msg')) return 'Outlook Message (.msg)';
                    if (lower.endsWith('.txt')) return 'Text File (.txt)';
                    if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'HTML File';
                    return 'Unknown';
                }

                updateThinkingMode(value) {
                    const v = (value || 'off').toLowerCase();
                    this.thinkingEnabled = v !== 'off';
                    if (this.thinkingEnabled) this.thinkingLevel = v;
                    this.updateThinkingControls();
                    this.refreshThinkingMenuLabel();
                    if (v === 'off') this.resetReasoningState();
                }

                updateThinkingControls() {
                    const enabled = !this.messageInput?.disabled;
                    this.refreshThinkingMenuLabel();
                    if (this.thinkingStatus) {
                        this.thinkingStatus.classList.toggle('hidden', !enabled);
                        if (enabled) this.renderThinkingStatus();
                    }
                    this.updateJsonToggleState();
                }

                enableChat() {
                    this.messageInput.disabled = false;
                    this.sendButton.disabled = false;
                    this.messageInput.placeholder = "Ask me anything about this email...";
                    this.updateThinkingControls();
                }

                addEmailContextMessage(emailData) {
                    const subject = window.ComposerAI.escapeHtml(emailData.subject || 'No subject');
                    const from = window.ComposerAI.escapeHtml(emailData.from || 'Unknown sender');
                    const dateLabel = window.ComposerAI.escapeHtml(emailData.date || 'Unknown date');
                    const iso = (emailData.dateIso || '').trim();
                    const previewMd = (emailData.parsedMarkdown || emailData.parsedPlain || '').trim();
                    const previewId = 'email-preview-' + (++this.previewCounter);
                    const previewHtml = previewMd.length > 0 ? window.ComposerAI.renderMarkdown(previewMd) : '<p class="text-xs italic text-slate-500">Email preview unavailable.</p>';

                    const toggleWrapper = document.createElement('div');
                    toggleWrapper.className = 'overflow-hidden rounded-2xl border border-blue-200/60 bg-blue-50/40';
                    toggleWrapper.innerHTML =
                        '<div class="flex items-center gap-2 px-3.5 py-2.5">' +
                        '<button type="button" class="flex flex-1 items-center gap-3 rounded-xl px-2 py-1.5 text-left transition hover:bg-blue-100/70 focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-200" data-role="preview-toggle" aria-expanded="false" aria-controls="' + previewId + '">' +
                        '<span class="flex h-9 w-9 flex-shrink-0 items-center justify-center rounded-xl bg-blue-100 text-blue-700">' +
                        '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M2.25 6.75A3.75 3.75 0 016 3h12a3.75 3.75 0 013.75 3.75v10.5A3.75 3.75 0 0118 21H6a3.75 3.75 0 01-3.75-3.75V6.75zm3.82-.456a.75.75 0 00-.82 1.26l6 3.9a.75.75 0 00.82 0l6-3.9a.75.75 0 00-.82-1.26L12 9.694 6.07 6.294z"/></svg>' +
                        '</span>' +
                        '<span class="flex-1 truncate text-sm font-semibold text-slate-800">' + subject + '</span>' +
                        '<span class="ml-auto flex flex-shrink-0 items-center gap-2">' +
                        '<span class="rounded-md bg-white/70 px-2 py-1 text-[11px] font-semibold uppercase tracking-[0.18em] text-slate-600" data-role="email-date" data-original-label="' + dateLabel + '" ' + (iso ? 'data-date-iso="' + window.ComposerAI.escapeHtml(iso) + '"' : '') + '>' + dateLabel + '</span>' +
                        '<svg class="h-4 w-4 text-slate-500 transition-transform" data-role="preview-chevron" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>' +
                        '</span>' +
                        '</button>' +
                        '<button type="button" data-role="quick-insights" class="group flex h-8 w-8 flex-shrink-0 items-center justify-center rounded-lg bg-gradient-to-br from-violet-500 to-indigo-600 text-white shadow-sm transition-all hover:shadow-md hover:scale-110 focus:outline-none focus-visible:ring-2 focus-visible:ring-violet-300" title="Get AI insights about this email" aria-label="Analyze email with AI">' +
                        '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">' +
                        '<path d="M9.813 3.063l.75 3.75m3.937-3.75l-.75 3.75m-6 .937l3.75.75m9.375 0l-3.75.75m-9.375 6l3.75-.75m9.375 0l-3.75-.75m-6 5.063l.75-3.75m3.937 3.75l-.75-3.75M12 18.75a6.75 6.75 0 100-13.5 6.75 6.75 0 000 13.5z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>' +
                        '</svg>' +
                        '</button>' +
                        '</div>' +
                        '<div id="' + previewId + '" data-role="preview-body" class="hidden border-t border-blue-100/70 bg-white/90 px-3.5 py-3">' +
                        '<div class="chat-markdown">' +
                        '<p><strong>From:</strong> ' + from + '</p>' +
                        '<div class="chat-markdown">' + previewHtml + '</div>' +
                        '</div>' +
                        '</div>';

                    const toggleBtn = toggleWrapper.querySelector('[data-role="preview-toggle"]');
                    const previewBody = toggleWrapper.querySelector('[data-role="preview-body"]');
                    const previewChevron = toggleWrapper.querySelector('[data-role="preview-chevron"]');
                    const insightsBtn = toggleWrapper.querySelector('[data-role="quick-insights"]');

                    toggleBtn.addEventListener('click', (e) => {
                        // Don't toggle if clicking the insights button
                        if (e.target.closest('[data-role="quick-insights"]')) return;

                        const expanded = toggleBtn.getAttribute('aria-expanded') === 'true';
                        const nextExpanded = !expanded;
                        toggleBtn.setAttribute('aria-expanded', String(nextExpanded));
                        previewBody.classList.toggle('hidden', !nextExpanded);
                        previewChevron.style.transform = nextExpanded ? 'rotate(180deg)' : 'rotate(0)';
                    });

                    // Quick Insights: Trigger backend insights endpoint (all logic in Java)
                    insightsBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Don't trigger toggle
                        this.triggerInsights();
                    });

                    const wrapper = document.createElement('div');
                    wrapper.className = 'message-block w-full';
                    const surface = document.createElement('div');
                    surface.className = 'assistant-surface';
                    surface.appendChild(toggleWrapper);
                    wrapper.appendChild(surface);
                    this.messages.appendChild(wrapper);
                    this.localizeDate(toggleWrapper.querySelector('[data-role="email-date"]'));
                    this.applyMarkdownEnhancements(surface);
                    this.messages.scrollTop = this.messages.scrollHeight;
                }

                buildChatPayload(message, jsonOutput) {
                    const contextId = this.currentEmailContext?.contextId || null;
                    const payload = {
                        message,
                        conversationId: this.conversationId,
                        maxResults: this.defaultMaxResults,
                        contextId,
                        thinkingEnabled: this.thinkingEnabled,
                        thinkingLevel: this.thinkingEnabled ? this.thinkingLevel : null,
                        jsonOutput: !!jsonOutput
                    };

                    const rawContext = this.currentEmailContext?.contextForAI;
                    if (contextId && rawContext) {
                        payload.emailContext = rawContext.length > this.maxEmailContextChars
                            ? rawContext.slice(0, this.maxEmailContextChars)
                            : rawContext;
                    }

                    return payload;
                }

                async sendMessage() {
                    const message = this.messageInput.value.trim();
                    if (!message || this.isStreaming) return;

                    if (this.activeStreamController) {
                        try { this.activeStreamController.abort(); } catch (_) { }
                    }
                    this.addMessage(message, 'user');
                    this.messageInput.value = '';

                    const isJsonMode = this.jsonOutput;
                    const assistantDiv = this.addMessage('', 'assistant');
                    if (isJsonMode) {
                        assistantDiv.innerHTML = '<div class="phase-badge phase-streaming">Preparing JSON...</div><pre class="' + this.jsonPreClass + '"></pre>';
                    } else {
                        assistantDiv.innerHTML = '<div class="assistant-thinking relative"><div class="phase-badge phase-thinking">' + (this.thinkingEnabled ? 'Thinking...' : 'Parsing your email...') + '</div><div class="thinking-skeleton rounded-xl border border-slate-200 bg-slate-50/80 p-3"><div class="thinking-line"></div><div class="thinking-line"></div><div class="thinking-line short"></div><div class="thinking-cursor-bar"></div></div></div>';
                    }

                    const payload = this.buildChatPayload(message, isJsonMode);

                    this.messageInput.disabled = true;
                    this.sendButton.disabled = true;
                    this.updateThinkingControls();
                    this.isStreaming = true;
                    this.activeStreamController = new AbortController();
                    const timeoutId = setTimeout(() => {
                        try { this.activeStreamController?.abort(); } catch (_) { }
                    }, this.streamTimeoutMs);

                    try {
                        await this.streamResponse(payload, assistantDiv, this.activeStreamController.signal);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Request timed out. Please try again.');
                        } else {
                            try {
                                await this.sendChatRequest(payload, assistantDiv);
                            } catch (fallbackError) {
                                assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Sorry, I encountered an error. Please try again.');
                            }
                        }
                    } finally {
                        clearTimeout(timeoutId);
                        this.isStreaming = false;
                        this.activeStreamController = null;
                        this.messageInput.disabled = false;
                        this.sendButton.disabled = false;
                        this.updateThinkingControls();
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                async triggerInsights() {
                    if (this.isStreaming) return;

                    if (this.activeStreamController) {
                        try { this.activeStreamController.abort(); } catch (_) { }
                    }

                    // Skip user message bubble - go straight to assistant response
                    const assistantDiv = this.addMessage('', 'assistant');
                    assistantDiv.innerHTML = '<div class="assistant-thinking relative"><div class="phase-badge phase-thinking">Analyzing email...</div><div class="thinking-skeleton rounded-xl border border-slate-200 bg-slate-50/80 p-3"><div class="thinking-line"></div><div class="thinking-line"></div><div class="thinking-line short"></div><div class="thinking-cursor-bar"></div></div></div>';

                    const payload = this.buildChatPayload(this.insightsTrigger, false);

                    this.messageInput.disabled = true;
                    this.sendButton.disabled = true;
                    this.updateThinkingControls();
                    this.isStreaming = true;
                    this.activeStreamController = new AbortController();
                    const timeoutId = setTimeout(() => {
                        try { this.activeStreamController?.abort(); } catch (_) { }
                    }, this.streamTimeoutMs);

                    try {
                        // Call insights-specific endpoint
                        await this.streamInsightsResponse(payload, assistantDiv, this.activeStreamController.signal);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Request timed out. Please try again.');
                        } else {
                            assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Sorry, I encountered an error. Please try again.');
                        }
                    } finally {
                        clearTimeout(timeoutId);
                        this.isStreaming = false;
                        this.activeStreamController = null;
                        this.messageInput.disabled = false;
                        this.sendButton.disabled = false;
                        this.updateThinkingControls();
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                async streamInsightsResponse(payload, targetDiv, signal) {
                    // Call insights endpoint - backend controls the prompt
                    const response = await fetch('/api/chat/insights/stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-UI-Request': UI_NONCE },
                        body: JSON.stringify(payload),
                        signal
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);

                    const timeoutHint = response.headers.get('X-Stream-Timeout-Hint');
                    if (timeoutHint) {
                        const parsed = parseInt(timeoutHint, 10);
                        if (!isNaN(parsed) && parsed > 0) this.streamTimeoutMs = parsed;
                    }

                    // Use same streaming logic as regular chat
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    const isJsonMode = false; // Insights always uses normal mode
                    let html = '';
                    let buffer = '';
                    let firstToken = true;
                    let conversationIdFromServer = null;
                    let currentEvent = null;
                    let currentEventData = [];
                    let streamFinished = false;

                    const finalizeStream = () => {
                        if (html) {
                            targetDiv.innerHTML = html;
                            this.applyMarkdownEnhancements(targetDiv);
                        } else {
                            targetDiv.innerHTML = window.ComposerAI.renderMarkdown("I don't have a response to that.");
                            this.applyMarkdownEnhancements(targetDiv);
                        }
                        this.conversationId = conversationIdFromServer || payload.conversationId || this.conversationId;
                        this.resetReasoningState();
                        streamFinished = true;
                    };

                    const router = new SSEEventRouter()
                        .on(SSE_EVENTS.METADATA, (raw) => {
                            if (!raw) return;
                            try {
                                const metadata = JSON.parse(raw);
                                if (metadata.conversationId) conversationIdFromServer = metadata.conversationId;
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse metadata event', err);
                            }
                        })
                        .on(SSE_EVENTS.RENDERED_HTML, (chunk) => {
                            if (chunk == null) return;
                            if (firstToken) {
                                targetDiv.innerHTML = '<div class="phase-badge phase-streaming">Streaming...</div>';
                                firstToken = false;
                            }
                            html += chunk || '';
                            targetDiv.innerHTML = html + '<span class="streaming-cursor">|</span>';
                            this.scrollIfAtBottom();
                        })
                        .on(SSE_EVENTS.REASONING, (raw) => {
                            if (!raw) return;
                            try {
                                this.updateStreamState(JSON.parse(raw));
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse reasoning payload', err);
                            }
                        })
                        .on(SSE_EVENTS.ERROR, (message) => {
                            throw new Error(message || 'Stream error occurred');
                        })
                        .on(SSE_EVENTS.DONE, () => finalizeStream());

                    while (!streamFinished) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            const cleanedLine = line.endsWith('\r') ? line.slice(0, -1) : line;

                            if (cleanedLine.startsWith('event:')) {
                                if (currentEvent && currentEventData.length) {
                                    router.route(currentEvent, currentEventData.join('\n'));
                                } else if (currentEvent && currentEventData.length === 0) {
                                    router.route(currentEvent, '');
                                }
                                currentEvent = cleanedLine.substring(6).trim();
                                currentEventData = [];
                                continue;
                            }

                            if (cleanedLine.startsWith('data:')) {
                                const value = cleanedLine.length >= 6 && cleanedLine.charAt(5) === ' '
                                    ? cleanedLine.substring(6)
                                    : cleanedLine.substring(5);
                                currentEventData.push(value);
                                continue;
                            }

                            if (cleanedLine === '') {
                                if (currentEvent) {
                                    const payload = currentEventData.length > 0
                                        ? currentEventData.join('\n')
                                        : '';
                                    router.route(currentEvent, payload);
                                }
                                currentEvent = null;
                                currentEventData = [];
                                if (streamFinished) break;
                                continue;
                            }
                        }
                    }

                    if (!streamFinished) {
                        if (currentEvent) {
                            const payload = currentEventData.length > 1
                                ? currentEventData.join('\n')
                                : (currentEventData[0] ?? '');
                            router.route(currentEvent, payload);
                        }
                        finalizeStream();
                    }
                }

                async sendChatRequest(payload, targetDiv) {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-UI-Request': UI_NONCE },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    const result = await response.json();
                    const isJsonMode = !!payload.jsonOutput;
                    const html = (result.sanitizedHtml || result.sanitizedHTML || result.renderedHtml || result.renderedHTML || '').trim();
                    const raw = (result.rawMarkdown || result.response || result.message || '').trim();
                    if (isJsonMode) {
                        const pre = document.createElement('pre');
                        pre.className = this.jsonPreClass;
                        if (raw) {
                            try {
                                const parsed = JSON.parse(raw);
                                pre.textContent = JSON.stringify(parsed, null, 2);
                            } catch (_) {
                                pre.textContent = raw;
                            }
                        } else {
                            pre.textContent = '{ }';
                        }
                        targetDiv.innerHTML = '';
                        targetDiv.appendChild(pre);
                    } else {
                        if (html) {
                            targetDiv.innerHTML = html;
                            this.applyMarkdownEnhancements(targetDiv);
                        } else {
                            targetDiv.innerHTML = window.ComposerAI.renderMarkdown(raw || 'I received your message about the email.');
                            this.applyMarkdownEnhancements(targetDiv);
                        }
                    }
                    if (result.conversationId) this.conversationId = result.conversationId;
                }

                async streamResponse(payload, targetDiv, signal) {
                    const response = await fetch('/api/chat/stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-UI-Request': UI_NONCE },
                        body: JSON.stringify(payload),
                        signal
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);

                    const timeoutHint = response.headers.get('X-Stream-Timeout-Hint');
                    if (timeoutHint) {
                        const parsed = parseInt(timeoutHint, 10);
                        if (!isNaN(parsed) && parsed > 0) this.streamTimeoutMs = parsed;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let isJsonMode = !!payload.jsonOutput;
                    let html = '';
                    let jsonBuffer = '';
                    let buffer = '';
                    let firstToken = true;
                    let jsonPre = null;
                    let conversationIdFromServer = null;
                    let currentEvent = null;
                    let currentEventData = [];
                    let streamFinished = false;

                    const finalizeStream = () => {
                        if (isJsonMode) {
                            if (jsonPre) {
                                try {
                                    const parsed = JSON.parse(jsonBuffer);
                                    jsonPre.textContent = JSON.stringify(parsed, null, 2);
                                } catch (_) {
                                    jsonPre.textContent = jsonBuffer || '{ }';
                                }
                            } else if (jsonBuffer) {
                                const pre = document.createElement('pre');
                                pre.className = this.jsonPreClass;
                                try {
                                    const parsed = JSON.parse(jsonBuffer);
                                    pre.textContent = JSON.stringify(parsed, null, 2);
                                } catch (_) {
                                    pre.textContent = jsonBuffer;
                                }
                                targetDiv.innerHTML = '';
                                targetDiv.appendChild(pre);
                            } else {
                                targetDiv.innerHTML = window.ComposerAI.renderMarkdown('No response received.');
                            }
                        } else {
                            if (html) {
                                targetDiv.innerHTML = html;
                                this.applyMarkdownEnhancements(targetDiv);
                            } else {
                            targetDiv.innerHTML = window.ComposerAI.renderMarkdown("I don't have a response to that.");
                            this.applyMarkdownEnhancements(targetDiv);
                            }
                        }
                        this.conversationId = conversationIdFromServer || payload.conversationId || this.conversationId;
                        this.resetReasoningState();
                        streamFinished = true;
                    };

                    const router = new SSEEventRouter()
                        .on(SSE_EVENTS.METADATA, (raw) => {
                            if (!raw) return;
                            try {
                                const metadata = JSON.parse(raw);
                                if (metadata.conversationId) conversationIdFromServer = metadata.conversationId;
                                if (metadata.jsonOutput !== undefined) {
                                    isJsonMode = Boolean(metadata.jsonOutput);
                                }
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse metadata event', err);
                            }
                        })
                        .on(SSE_EVENTS.RENDERED_HTML, (chunk) => {
                            if (chunk == null || isJsonMode) return;
                            if (firstToken) {
                                targetDiv.innerHTML = '<div class="phase-badge phase-streaming">Streaming...</div>';
                                firstToken = false;
                            }
                            html += chunk || '';
                            targetDiv.innerHTML = html + '<span class="streaming-cursor">|</span>';
                            this.scrollIfAtBottom();
                        })
                        .on(SSE_EVENTS.RAW_JSON, (chunk) => {
                            if (chunk == null || !isJsonMode) return;
                            jsonBuffer += chunk;
                            if (firstToken) {
                                targetDiv.innerHTML = '<div class="phase-badge phase-streaming">Streaming JSON...</div><pre class="' + this.jsonPreClass + '"></pre>';
                                jsonPre = targetDiv.querySelector('pre');
                                firstToken = false;
                            }
                            if (jsonPre) {
                                jsonPre.textContent = jsonBuffer;
                            }
                            this.scrollIfAtBottom();
                        })
                        .on(SSE_EVENTS.REASONING, (raw) => {
                            if (!raw) return;
                            try {
                                this.updateStreamState(JSON.parse(raw));
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse reasoning payload', err);
                            }
                        })
                        .on(SSE_EVENTS.ERROR, (message) => {
                            throw new Error(message || 'Stream error occurred');
                        })
                        .on(SSE_EVENTS.DONE, () => finalizeStream());

                    while (!streamFinished) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        // SSE spec allows multiple data: lines per event; accumulate until blank line terminator.
                        for (const line of lines) {
                            const cleanedLine = line.endsWith('\r') ? line.slice(0, -1) : line;

                            if (cleanedLine.startsWith('event:')) {
                                if (currentEvent && currentEventData.length) {
                                    router.route(currentEvent, currentEventData.join('\n'));
                                } else if (currentEvent && currentEventData.length === 0) {
                                    router.route(currentEvent, '');
                                }
                                currentEvent = cleanedLine.substring(6).trim();
                                currentEventData = [];
                                continue;
                            }

                            if (cleanedLine.startsWith('data:')) {
                                const value = cleanedLine.length >= 6 && cleanedLine.charAt(5) === ' '
                                    ? cleanedLine.substring(6)
                                    : cleanedLine.substring(5);
                                currentEventData.push(value);
                                continue;
                            }

                            if (cleanedLine === '') {
                                if (currentEvent) {
                                    const payload = currentEventData.length > 0
                                        ? currentEventData.join('\n')
                                        : '';
                                    router.route(currentEvent, payload);
                                }
                                currentEvent = null;
                                currentEventData = [];
                                if (streamFinished) break;
                                continue;
                            }
                        }
                    }

                    if (!streamFinished) {
                        if (currentEvent) {
                            const payload = currentEventData.length > 1
                                ? currentEventData.join('\n')
                                : (currentEventData[0] ?? '');
                            router.route(currentEvent, payload);
                        }
                        finalizeStream();
                    }
                }

                scrollIfAtBottom() {
                    if (this.messages.scrollTop + this.messages.clientHeight >= this.messages.scrollHeight - 50) {
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                localizeDate(elem) {
                    if (!elem) return;
                    const iso = elem.getAttribute('data-date-iso');
                    const original = elem.getAttribute('data-original-label') || '';
                    if (!iso) {
                        if (!elem.textContent?.trim()) {
                            elem.textContent = original;
                        }
                        return;
                    }
                    try {
                        const localDate = new Date(iso);
                        if (!isNaN(localDate.getTime())) {
                            const formatted = localDate.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
                            elem.textContent = formatted;
                            elem.setAttribute('title', 'Original: ' + original + '\nISO: ' + iso);
                            return;
                        }
                    } catch (_) { }
                    elem.textContent = original;
                }

                addMessage(content, sender) {
                    const div = document.createElement('div');
                    if (sender === 'user') {
                        div.className = 'message-user max-w-[60%] rounded-2xl bg-slate-900 text-white px-4 py-2.5 shadow-sm';
                        div.textContent = content;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'message-block w-full justify-end';
                        wrapper.appendChild(div);
                        this.messages.appendChild(wrapper);
                    } else {
                        const surface = document.createElement('div');
                        surface.className = 'assistant-surface';
                        const markdownContainer = document.createElement('div');
                        markdownContainer.className = 'chat-markdown';
                        if (content?.trim()) {
                            markdownContainer.innerHTML = window.ComposerAI.renderMarkdown(content);
                            this.applyMarkdownEnhancements(markdownContainer);
                        }
                        surface.appendChild(markdownContainer);
                        div.appendChild(surface);
                        const wrapper = document.createElement('div');
                        wrapper.className = 'message-block w-full';
                        wrapper.appendChild(surface);
                        this.messages.appendChild(wrapper);
                        return markdownContainer;
                    }
                    this.messages.scrollTop = this.messages.scrollHeight;
                    return div;
                }

                applyMarkdownEnhancements(root) {
                    if (!root) return;
                    const blocks = (root.classList && root.classList.contains('chat-markdown'))
                        ? [root]
                        : Array.from(root.querySelectorAll('.chat-markdown'));
                    if (blocks.length === 0) return;

                    blocks.forEach(block => {
                        block.querySelectorAll('table').forEach(table => {
                            table.classList.add('chat-table');
                            if (!table.closest('.chat-table-wrapper')) {
                                const wrapper = document.createElement('div');
                                wrapper.className = 'chat-table-wrapper';
                                const parent = table.parentNode;
                                if (parent) {
                                    parent.insertBefore(wrapper, table);
                                    wrapper.appendChild(table);
                                }
                            }
                        });

                        block.querySelectorAll('pre').forEach(pre => {
                            pre.classList.add('chat-code-block');
                        });

                        block.querySelectorAll('code').forEach(code => {
                            if (code.parentElement && code.parentElement.tagName === 'PRE') return;
                            code.classList.add('chat-inline-code');
                        });

                        block.querySelectorAll('blockquote').forEach(quote => {
                            quote.classList.add('chat-blockquote');
                        });
                    });
                }

                updateStreamState(message) {
                    if (!message || !message.type || !message.phase) return;
                    const phase = String(message.phase).toLowerCase();
                    const type = String(message.type).toUpperCase();
                    this.streamState.thinking = { active: true, phase, lastType: type, message };
                    this.renderThinkingStatus(message);
                }

                renderThinkingStatus(message = {}) {
                    if (!this.thinkingStatus) return;
                    const { active } = this.streamState.thinking || {};
                    if (!active) {
                        this.thinkingStatus.textContent = 'Thinking disabled for faster responses.';
                        return;
                    }
                    const label = (message.displayLabel || 'Reasoningâ€¦').trim();
                    this.thinkingStatus.textContent = label;
                }

                resetReasoningState() {
                    this.streamState.thinking = { active: false, phase: 'idle', lastType: null, message: null };
                    if (this.thinkingStatus) {
                        this.thinkingStatus.textContent = 'Thinking disabled for faster responses.';
                    }
                }
            }

            document.addEventListener('DOMContentLoaded', function () {
                try {
                    new ComposerAIChat();
                } catch (error) {
                    console.error('ComposerAI: Failed to initialize chat interface:', error);
                }
            });
        </script>
    </div>
</body>

</html>
