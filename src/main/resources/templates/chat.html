<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      th:replace="~{layout :: layout(~{::body/content}, 'ComposerAI - Email Chat Interface', ~{::head/extraHead})}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ComposerAI - Email Chat Interface</title>
    <th:block th:fragment="extraHead"></th:block>
</head>
<body>
    <div th:fragment="content" class="min-h-screen bg-slate-100/80 py-12">
        <div class="mx-auto flex max-w-6xl flex-col gap-10 px-4 sm:px-6 lg:px-8">
            <header class="relative overflow-hidden rounded-3xl border border-slate-200 bg-white/90 p-8 shadow-ultra shadow-slate-900/10 backdrop-blur">
                <div class="absolute inset-0 bg-subtle-glow"></div>
                <div class="relative z-10 flex flex-col gap-4">
                    <h1 class="text-3xl font-semibold tracking-tight text-slate-900 sm:text-4xl">ComposerAI Chat</h1>
                    <p class="max-w-2xl text-base text-slate-600">Upload an email and chat about it with AI assistance</p>
                    <div class="flex flex-wrap items-center gap-3">
                        <span class="inline-flex items-center rounded-full border border-slate-200 bg-white px-3 py-1 text-xs font-semibold uppercase tracking-[0.2em] text-slate-600">Chat Interface</span>
                        <span class="inline-flex items-center rounded-full border border-slate-200 bg-slate-100 px-3 py-1 text-xs font-medium text-slate-700">Supports .eml, .msg, .txt</span>
                    </div>
                </div>
            </header>

            <div th:replace="~{fragments/file-upload-tool :: uploadSection}"></div>

            <section class="rounded-3xl border border-slate-200 bg-white/90 shadow-ultra shadow-slate-900/10 backdrop-blur overflow-hidden">
                <div id="messages" class="flex flex-col gap-4 p-8 min-h-[400px] max-h-[500px] overflow-y-auto bg-slate-50">
                    <div class="message-assistant max-w-[70%] rounded-2xl bg-white border border-slate-200 p-4 shadow-sm">
                        <div class="text-slate-800">Hello! I'm ComposerAI. Upload an email file above and I'll help you analyze and discuss it.</div>
                    </div>
                </div>

                <div class="border-t border-slate-200 bg-white p-6">
                    <div class="mb-4 flex flex-wrap items-center gap-3 text-xs sm:text-sm text-slate-600">
                        <div id="thinkingDropdown">
                            <button id="thinkingMenuButton" type="button" aria-haspopup="listbox" aria-expanded="false" class="inline-flex items-center justify-between gap-2 rounded-xl border border-slate-300 bg-white px-3 py-1 font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50">
                                <span id="thinkingMenuLabel">Thinking: Off</span>
                                <svg class="h-3 w-3 text-slate-500 transition-transform" viewbox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/></svg>
                            </button>
                        </div>
                        <div id="thinkingMenu" class="thinking-dropdown-menu fixed z-[9999] w-64 rounded-xl border border-slate-200 bg-white p-1 shadow-xl ring-1 ring-black/5 hidden">
                            <div role="menu">
                                <button type="button" role="menuitem" data-value="off" class="w-full rounded-lg px-3 py-2 text-left text-sm font-medium text-slate-700 hover:bg-slate-50">Off</button>
                                <div class="my-1 border-t border-slate-200"></div>
                                <button type="button" role="menuitem" data-value="minimal" class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Minimal</button>
                                <button type="button" role="menuitem" data-value="low" class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Low</button>
                                <button type="button" role="menuitem" data-value="medium" class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Medium</button>
                                <button type="button" role="menuitem" data-value="high" class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">High</button>
                            </div>
                        </div>
                        <span id="thinkingStatus" class="hidden text-slate-500"></span>
                    </div>
                    <div class="flex items-center gap-3">
                        <textarea id="messageInput" class="flex-1 resize-none rounded-2xl border border-slate-300 px-4 py-3 text-sm focus:border-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-200" placeholder="Type your message about the email..." rows="1" disabled></textarea>
                        <button id="sendButton" class="flex h-10 w-10 items-center justify-center rounded-full bg-slate-900 text-white transition-all hover:bg-slate-700 disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>
                            <span class="text-xl">&rarr;</span>
                        </button>
                    </div>
                </div>
            </section>

            <footer class="rounded-2xl border border-slate-200 bg-white/50 px-6 py-3 text-center text-sm text-slate-600 backdrop-blur">
                ComposerAI &bull; Professional Email Analysis &bull; Upload an email to begin
            </footer>
        </div>

        <div id="sse-event-names"
             th:attr="data-metadata=${T(com.composerai.api.dto.SseEventType).METADATA.eventName},
                      data-rendered_html=${T(com.composerai.api.dto.SseEventType).RENDERED_HTML.eventName},
                      data-done=${T(com.composerai.api.dto.SseEventType).DONE.eventName},
                      data-error=${T(com.composerai.api.dto.SseEventType).ERROR.eventName},
                      data-reasoning=${T(com.composerai.api.dto.SseEventType).REASONING.eventName}"
             hidden></div>

        <script>
            const eventDataset = document.getElementById('sse-event-names')?.dataset || {};
            const SSE_EVENTS = Object.freeze({
                METADATA: eventDataset.metadata || 'metadata',
                RENDERED_HTML: eventDataset.rendered_html || 'rendered_html',
                DONE: eventDataset.done || 'done',
                ERROR: eventDataset.error || 'error',
                REASONING: eventDataset.reasoning || 'reasoning'
            });

            class SSEEventRouter {
                constructor() {
                    this.handlers = new Map();
                }

                on(eventType, handler) {
                    if (typeof handler === 'function') {
                        this.handlers.set(eventType, handler);
                    }
                    return this;
                }

                route(eventType, data) {
                    const handler = this.handlers.get(eventType);
                    if (handler) handler(data);
                }
            }

            class ComposerAIChat {
                constructor() {
                    this.messages = document.getElementById('messages');
                    this.messageInput = document.getElementById('messageInput');
                    this.sendButton = document.getElementById('sendButton');
                    this.fileDropArea = document.getElementById('fileDropArea');
                    this.fileInput = document.getElementById('fileInput');
                    this.fileInfo = document.getElementById('fileInfo');
                    this.uploadStatus = document.getElementById('uploadStatus');
                    this.currentEmailContext = null;
                    this.conversationId = null;
                    this.activeStreamController = null;
                    this.isStreaming = false;
                    this.streamState = { thinking: { active: false, phase: 'idle', lastType: null, message: null } };
                    this.thinkingStatus = document.getElementById('thinkingStatus');
                    this.thinkingEnabled = false;
                    this.thinkingLevel = 'medium';
                    this.streamTimeoutMs = 120000; // Default 2 minutes, updated from server
                    this.initializeEventListeners();
                }

                initializeEventListeners() {
                    this.sendButton?.addEventListener('click', () => this.sendMessage());
                    this.messageInput?.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });

                    if (this.fileDropArea && this.fileInput && window.ComposerAI?.FileUploadHandler) {
                        new window.ComposerAI.FileUploadHandler({
                            dropArea: this.fileDropArea,
                            fileInput: this.fileInput,
                            onFileSelected: (file) => this.handleFileUpload(file),
                            validExtensions: ['.eml', '.msg', '.txt']
                        });
                    }

                    this.initializeThinkingDropdown();
                    this.updateThinkingControls();
                    this.resetReasoningState();
                }

                initializeThinkingDropdown() {
                    const btn = document.getElementById('thinkingMenuButton');
                    const menu = document.getElementById('thinkingMenu');
                    const label = document.getElementById('thinkingMenuLabel');
                    if (!btn || !menu) return;

                    const setOpen = (open) => {
                        if (open) {
                            const rect = btn.getBoundingClientRect();
                            const spaceBelow = window.innerHeight - rect.bottom;
                            const menuHeight = 240;
                            if (spaceBelow >= menuHeight || spaceBelow > rect.top) {
                                menu.style.top = rect.bottom + 8 + 'px';
                                menu.style.bottom = 'auto';
                            } else {
                                menu.style.bottom = window.innerHeight - rect.top + 8 + 'px';
                                menu.style.top = 'auto';
                            }
                            menu.style.left = rect.left + 'px';
                            menu.classList.remove('hidden');
                        } else {
                            menu.classList.add('hidden');
                        }
                        btn.setAttribute('aria-expanded', String(open));
                        btn.querySelector('svg').style.transform = open ? 'rotate(180deg)' : 'rotate(0)';
                    };

                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        setOpen(btn.getAttribute('aria-expanded') !== 'true');
                    });
                    document.addEventListener('click', (e) => {
                        if (!menu.contains(e.target) && !btn.contains(e.target)) setOpen(false);
                    });
                    window.addEventListener('resize', () => {
                        if (btn.getAttribute('aria-expanded') === 'true') setOpen(true);
                    });

                    menu.querySelectorAll('button[data-value]').forEach(opt => {
                        opt.addEventListener('click', () => {
                            this.updateThinkingMode(opt.getAttribute('data-value'));
                            menu.querySelectorAll('button').forEach(b => b.classList.remove('bg-slate-100'));
                            opt.classList.add('bg-slate-100');
                            setOpen(false);
                        });
                    });

                    this.refreshThinkingMenuLabel = () => {
                        if (label) label.textContent = this.thinkingEnabled ?
                            'Thinking: ' + this.thinkingLevel.charAt(0).toUpperCase() + this.thinkingLevel.slice(1) :
                            'Thinking: Off';
                    };
                    this.refreshThinkingMenuLabel();
                }

                async handleFileUpload(file) {
                    this.showFileInfo(file);
                    this.uploadStatus.innerHTML = '<div class="rounded-lg bg-blue-100 border border-blue-200 p-3 text-sm text-blue-800">Uploading and parsing email...</div>';

                    try {
                        const result = await window.ComposerAI.parseEmailFile(file);
                        this.currentEmailContext = result;
                        this.conversationId = null;
                        this.uploadStatus.innerHTML = '<div class="rounded-lg bg-green-100 border border-green-200 p-3 text-sm text-green-800">Email uploaded and parsed successfully!</div>';
                        this.enableChat();
                        this.addEmailContextMessage(result);
                    } catch (error) {
                        this.uploadStatus.innerHTML = '<div class="rounded-lg bg-red-100 border border-red-200 p-3 text-sm text-red-800">Failed to upload email: ' + String(error?.message || 'Unknown error') + '</div>';
                    }
                }

                showFileInfo(file) {
                    this.fileInfo.innerHTML = '<strong>Selected file:</strong> ' + window.ComposerAI.escapeHtml(file.name) + '<br><strong>Size:</strong> ' + window.ComposerAI.formatFileSize(file.size) + '<br><strong>Type:</strong> ' + this.getFriendlyFileType(file.name);
                    this.fileInfo.classList.remove('hidden');
                }

                getFriendlyFileType(filename) {
                    const lower = filename.toLowerCase();
                    if (lower.endsWith('.eml')) return 'Email (.eml)';
                    if (lower.endsWith('.msg')) return 'Outlook Message (.msg)';
                    if (lower.endsWith('.txt')) return 'Text File (.txt)';
                    if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'HTML File';
                    return 'Unknown';
                }

                updateThinkingMode(value) {
                    const v = (value || 'off').toLowerCase();
                    this.thinkingEnabled = v !== 'off';
                    if (this.thinkingEnabled) this.thinkingLevel = v;
                    this.updateThinkingControls();
                    this.refreshThinkingMenuLabel();
                    if (v === 'off') this.resetReasoningState();
                }

                updateThinkingControls() {
                    const enabled = !this.messageInput?.disabled;
                    document.getElementById('thinkingMenuButton')?.toggleAttribute('disabled', !enabled);
                    this.refreshThinkingMenuLabel();
                    if (this.thinkingStatus) {
                        this.thinkingStatus.classList.toggle('hidden', !enabled);
                        if (enabled) this.renderThinkingStatus();
                    }
                }

                enableChat() {
                    this.messageInput.disabled = false;
                    this.sendButton.disabled = false;
                    this.messageInput.placeholder = "Ask me anything about this email...";
                    this.updateThinkingControls();
                }

                addEmailContextMessage(emailData) {
                    const msg = document.createElement('div');
                    msg.className = 'message-assistant max-w-[70%] rounded-2xl bg-blue-50 border border-blue-200 p-4 shadow-sm';
                    const subject = window.ComposerAI.escapeHtml(emailData.subject || 'No subject');
                    const from = window.ComposerAI.escapeHtml(emailData.from || 'Unknown sender');
                    const dateLabel = window.ComposerAI.escapeHtml(emailData.date || 'Unknown date');
                    const iso = (emailData.dateIso || '').trim();
                    msg.innerHTML = '<h4 class="font-semibold text-slate-900 mb-2">&#128231; Email Context Loaded</h4>' +
                        '<p class="text-sm text-slate-700"><strong>Subject:</strong> ' + subject + '</p>' +
                        '<p class="text-sm text-slate-700"><strong>From:</strong> ' + from + '</p>' +
                        '<p class="text-sm text-slate-700" data-role="email-date" data-original-label="' + dateLabel + '" ' + (iso ? 'data-date-iso="' + window.ComposerAI.escapeHtml(iso) + '"' : '') + '><strong>Date:</strong> ' + dateLabel + '</p>';

                    const previewMd = (emailData.parsedMarkdown || emailData.parsedPlain || '').trim();
                    if (previewMd.length > 0) {
                        const truncated = previewMd.length > 400 ? previewMd.substring(0, 400) + '...' : previewMd;
                        const previewDiv = document.createElement('div');
                        previewDiv.className = 'mt-3 pt-3 border-t border-blue-300';
                        previewDiv.innerHTML = '<p class="text-xs font-semibold text-slate-600 mb-1">Preview:</p><div class="prose prose-sm text-slate-600 max-w-none opacity-80">' + window.ComposerAI.renderMarkdown(truncated) + '</div>';
                        msg.appendChild(previewDiv);
                    }

                    this.messages.appendChild(msg);
                    this.localizeDate(msg.querySelector('[data-role="email-date"]'));
                    this.messages.scrollTop = this.messages.scrollHeight;
                }

                async sendMessage() {
                    const message = this.messageInput.value.trim();
                    if (!message || this.isStreaming) return;

                    if (this.activeStreamController) this.activeStreamController.abort();
                    this.addMessage(message, 'user');
                    this.messageInput.value = '';

                    const assistantDiv = this.addMessage('', 'assistant');
                    assistantDiv.innerHTML = '<div class="assistant-thinking relative"><div class="phase-badge phase-thinking">' + (this.thinkingEnabled ? 'Thinking...' : 'Parsing your email...') + '</div><div class="thinking-skeleton rounded-xl border border-slate-200 bg-slate-50/80 p-3"><div class="thinking-line"></div><div class="thinking-line"></div><div class="thinking-line short"></div><div class="thinking-cursor-bar"></div></div></div>';

                    const payload = {
                        message,
                        conversationId: this.conversationId,
                        maxResults: 5,
                        emailContext: this.currentEmailContext?.contextForAI || '',
                        thinkingEnabled: this.thinkingEnabled,
                        thinkingLevel: this.thinkingEnabled ? this.thinkingLevel : null
                    };

                    this.messageInput.disabled = true;
                    this.sendButton.disabled = true;
                    this.updateThinkingControls();
                    this.isStreaming = true;
                    this.activeStreamController = new AbortController();
                    const timeoutId = setTimeout(() => this.activeStreamController?.abort().catch(() => {}), this.streamTimeoutMs);

                    try {
                        await this.streamResponse(payload, assistantDiv, this.activeStreamController.signal);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Request timed out. Please try again.');
                        } else {
                            try {
                                await this.sendChatRequest(payload, assistantDiv);
                            } catch (fallbackError) {
                                assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Sorry, I encountered an error. Please try again.');
                            }
                        }
                    } finally {
                        clearTimeout(timeoutId);
                        this.isStreaming = false;
                        this.activeStreamController = null;
                        this.messageInput.disabled = false;
                        this.sendButton.disabled = false;
                        this.updateThinkingControls();
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                async sendChatRequest(payload, targetDiv) {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    const result = await response.json();
                    const html = (result.sanitizedHtml || result.sanitizedHTML || result.renderedHtml || result.renderedHTML || '').trim();
                    const raw = (result.rawMarkdown || result.response || result.message || '').trim();
                    targetDiv.innerHTML = html || window.ComposerAI.renderMarkdown(raw || 'I received your message about the email.');
                    if (result.conversationId) this.conversationId = result.conversationId;
                }

                async streamResponse(payload, targetDiv, signal) {
                    const response = await fetch('/api/chat/stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);

                    const timeoutHint = response.headers.get('X-Stream-Timeout-Hint');
                    if (timeoutHint) {
                        const parsed = parseInt(timeoutHint, 10);
                        if (!isNaN(parsed) && parsed > 0) this.streamTimeoutMs = parsed;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let html = '';
                    let buffer = '';
                    let firstToken = true;
                    let conversationIdFromServer = null;
                    let currentEvent = null;
                    let streamFinished = false;

                    const finalizeStream = () => {
                        targetDiv.innerHTML = html || window.ComposerAI.renderMarkdown("I don't have a response to that.");
                        this.conversationId = conversationIdFromServer || payload.conversationId || this.conversationId;
                        this.resetReasoningState();
                        streamFinished = true;
                    };

                    const router = new SSEEventRouter()
                        .on(SSE_EVENTS.METADATA, (raw) => {
                            if (!raw) return;
                            try {
                                const metadata = JSON.parse(raw);
                                if (metadata.conversationId) conversationIdFromServer = metadata.conversationId;
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse metadata event', err);
                            }
                        })
                        .on(SSE_EVENTS.RENDERED_HTML, (chunk) => {
                            if (chunk == null) return;
                            if (firstToken) {
                                targetDiv.innerHTML = '<div class="phase-badge phase-streaming">Streaming...</div>';
                                firstToken = false;
                            }
                            html += chunk;
                            targetDiv.innerHTML = html + '<span class="streaming-cursor">|</span>';
                            this.scrollIfAtBottom();
                        })
                        .on(SSE_EVENTS.REASONING, (raw) => {
                            if (!raw) return;
                            try {
                                this.updateStreamState(JSON.parse(raw));
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse reasoning payload', err);
                            }
                        })
                        .on(SSE_EVENTS.ERROR, (message) => {
                            throw new Error(message || 'Stream error occurred');
                        })
                        .on(SSE_EVENTS.DONE, () => finalizeStream());

                    while (!streamFinished) {
                        const {done, value} = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, {stream: true});
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.startsWith('event:')) {
                                currentEvent = line.substring(6).trim();
                            } else if (line.startsWith('data:')) {
                                const data = line.substring(5).trim();
                                if (currentEvent) {
                                    router.route(currentEvent, data);
                                }
                                currentEvent = null;
                                if (streamFinished) break;
                            }
                        }
                    }

                    if (!streamFinished) {
                        targetDiv.innerHTML = html || window.ComposerAI.renderMarkdown('No response received.');
                        this.conversationId = conversationIdFromServer || payload.conversationId || this.conversationId;
                        this.resetReasoningState();
                    }
                }

                scrollIfAtBottom() {
                    if (this.messages.scrollTop + this.messages.clientHeight >= this.messages.scrollHeight - 50) {
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                localizeDate(elem) {
                    if (!elem) return;
                    const iso = elem.getAttribute('data-date-iso');
                    if (!iso) return;
                    try {
                        const localDate = new Date(iso);
                        if (!isNaN(localDate.getTime())) {
                            const formatted = localDate.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
                            elem.innerHTML = '<strong>Date:</strong> ' + window.ComposerAI.escapeHtml(formatted);
                            elem.setAttribute('title', 'Original: ' + elem.getAttribute('data-original-label') + '\nISO: ' + iso);
                        }
                    } catch (err) {}
                }

                addMessage(content, sender) {
                    const div = document.createElement('div');
                    if (sender === 'user') {
                        div.className = 'message-user ml-auto max-w-[70%] rounded-2xl bg-slate-900 text-white p-4 shadow-sm';
                        div.textContent = content;
                    } else {
                        div.className = 'message-assistant max-w-[70%] rounded-2xl bg-white border border-slate-200 p-4 shadow-sm';
                        if (content?.trim()) div.innerHTML = window.ComposerAI.renderMarkdown(content);
                    }
                    this.messages.appendChild(div);
                    this.messages.scrollTop = this.messages.scrollHeight;
                    return div;
                }

                updateStreamState(message) {
                    if (!message || !message.type || !message.phase) return;
                    const phase = String(message.phase).toLowerCase();
                    const type = String(message.type).toUpperCase();
                    this.streamState.thinking = { active: true, phase, lastType: type, message };
                    this.renderThinkingStatus(message);
                }

                renderThinkingStatus(message = {}) {
                    if (!this.thinkingStatus) return;
                    const {active} = this.streamState.thinking || {};
                    if (!active) {
                        this.thinkingStatus.textContent = 'Thinking disabled for faster responses.';
                        return;
                    }
                    const label = (message.displayLabel || 'Reasoningâ€¦').trim();
                    this.thinkingStatus.textContent = label;
                }

                resetReasoningState() {
                    this.streamState.thinking = { active: false, phase: 'idle', lastType: null, message: null };
                    if (this.thinkingStatus) {
                        this.thinkingStatus.textContent = 'Thinking disabled for faster responses.';
                    }
                }
            }

            document.addEventListener('DOMContentLoaded', function() {
                try {
                    new ComposerAIChat();
                } catch (error) {
                    console.error('ComposerAI: Failed to initialize chat interface:', error);
                }
            });
        </script>
    </div>
</body>
</html>
