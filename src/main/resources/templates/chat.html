<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
    th:replace="~{layout :: layout(~{::body/content}, 'ComposerAI - Email Chat Interface', ~{::head/extraHead})}">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ComposerAI - Email Chat Interface</title>
    <th:block th:fragment="extraHead">
        <link rel="stylesheet" th:href="@{/css/email-table.css}" />
        <link rel="stylesheet" th:href="@{/css/email-data-table.css}" />
        <style>
            .message-block { display: flex; }
            .message-user { max-width: 64%; }

            .app-nav {
                border-bottom: 1px solid rgba(148, 163, 184, 0.35);
                background: rgba(255, 255, 255, 0.9);
                box-shadow: 0 18px 45px -28px rgba(15, 23, 42, 0.28);
                -webkit-backdrop-filter: blur(10px);
                backdrop-filter: blur(10px);
            }

            .chat-shell {
                display: flex;
                flex-direction: column;
                border-radius: 26px;
                border: 1px solid rgba(148, 163, 184, 0.32);
                background: rgba(255, 255, 255, 0.92);
                box-shadow: 0 35px 65px -40px rgba(15, 23, 42, 0.38);
                min-height: 0;
                overflow: hidden;
            }

            .assistant-surface {
                width: 100%;
                border-radius: 16px;
                border: 1px solid rgba(148, 163, 184, 0.28);
                background: rgba(255, 255, 255, 0.88);
                box-shadow: 0 12px 24px -18px rgba(15, 23, 42, 0.25);
                padding: 0.85rem 1.15rem;
            }

            @media (min-width: 640px) {
                .assistant-surface {
                    padding: 1rem 1.35rem;
                }
            }

            .chat-markdown {
                color: #0f172a;
                font-size: 0.88rem;
                line-height: 1.55;
                display: flex;
                flex-direction: column;
                gap: 0.7rem;
            }

            .chat-markdown > :first-child { margin-top: 0; }
            .chat-markdown > :last-child { margin-bottom: 0; }

            .chat-markdown p { margin: 0; }
            .chat-markdown ul,
            .chat-markdown ol { margin: 0; padding-left: 1.05rem; }
            .chat-markdown li { margin-bottom: 0.35rem; }

            .chat-markdown a {
                color: #0f172a;
                text-decoration: underline;
                text-decoration-color: rgba(15, 23, 42, 0.35);
                text-underline-offset: 3px;
                text-decoration-thickness: 1px;
            }

            .chat-markdown a:hover { text-decoration-color: rgba(15, 23, 42, 0.6); }

            .chat-blockquote,
            .chat-markdown blockquote {
                border-left: 3px solid rgba(15, 23, 42, 0.25);
                background: rgba(226, 232, 240, 0.35);
                border-radius: 14px;
                padding: 0.7rem 1.05rem;
                margin: 0;
                color: #1f2937;
            }

            .chat-code-block,
            .chat-markdown pre {
                background: rgba(15, 23, 42, 0.96);
                color: rgba(248, 250, 252, 0.95);
                border-radius: 14px;
               padding: 0.75rem 0.9rem;
                border: 1px solid rgba(71, 85, 105, 0.4);
                overflow-x: auto;
                margin: 0;
                font-family: "SFMono-Regular", "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", monospace;
                font-size: 0.8rem;
                line-height: 1.52;
            }

            .chat-markdown code,
            .chat-inline-code {
                background: rgba(226, 232, 240, 0.6);
                border-radius: 6px;
                padding: 0.1rem 0.3rem;
                font-family: "SFMono-Regular", "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", monospace;
                font-size: 0.88em;
            }

            .chat-markdown pre code { background: transparent; padding: 0; border-radius: 0; }

            .chat-table-wrapper {
                margin: 0.5rem -0.35rem 0.85rem;
                padding: 0.45rem 0.65rem;
                border-radius: 14px;
                border: 1px solid rgba(148, 163, 184, 0.3);
                background: rgba(248, 250, 252, 0.82);
                overflow-x: auto;
            }

            .chat-table-wrapper::-webkit-scrollbar { height: 6px; }
            .chat-table-wrapper::-webkit-scrollbar-thumb {
                background: rgba(100, 116, 139, 0.5);
                border-radius: 9999px;
            }
            .chat-table-wrapper::-webkit-scrollbar-track {
                background: rgba(226, 232, 240, 0.4);
                border-radius: 9999px;
            }

            .chat-table,
            .chat-markdown table {
                width: 100%;
                min-width: 420px;
                border-collapse: collapse;
                color: #0f172a;
                font-size: 0.86rem;
            }

            .chat-table th,
            .chat-markdown th {
                text-align: left;
                letter-spacing: 0.08em;
                font-size: 0.7rem;
                font-weight: 600;
                padding: 0.48rem 0.65rem;
                background: rgba(226, 232, 240, 0.65);
                color: #1f2937;
                border-bottom: 1px solid rgba(148, 163, 184, 0.35);
            }

            .chat-table td,
            .chat-markdown td {
                padding: 0.48rem 0.65rem;
                border-bottom: 1px solid rgba(226, 232, 240, 0.55);
                vertical-align: top;
            }

            .chat-table tr:last-child td,
            .chat-markdown tr:last-child td { border-bottom: none; }

            @media (max-width: 640px) {
                .chat-table,
                .chat-markdown table { min-width: 360px; }
                .chat-table-wrapper { margin-left: -0.25rem; margin-right: -0.25rem; }
            }

            .chat-input {
                margin-top: auto;
                background: rgba(255, 255, 255, 0.96);
                -webkit-backdrop-filter: blur(8px);
                backdrop-filter: blur(8px);
            }

            .upload-status {
                margin-bottom: 0.75rem;
                border-radius: 12px;
                padding: 0.6rem 0.85rem;
                font-size: 0.8rem;
                font-weight: 500;
                display: none;
            }

            .upload-status.upload-status--info {
                display: block;
                background: rgba(59, 130, 246, 0.12);
                border: 1px solid rgba(59, 130, 246, 0.35);
                color: #1d4ed8;
            }

            .upload-status.upload-status--success {
                display: block;
                background: rgba(34, 197, 94, 0.12);
                border: 1px solid rgba(34, 197, 94, 0.35);
                color: #166534;
            }

            .upload-status.upload-status--error {
                display: block;
                background: rgba(248, 113, 113, 0.12);
                border: 1px solid rgba(248, 113, 113, 0.35);
                color: #b91c1c;
            }
        </style>
    </th:block>
</head>

<body>
    <div th:fragment="content" class="min-h-screen flex flex-col bg-slate-100/80">
        <nav class="app-nav px-4 py-3.5 sm:px-6">
            <a href="/chat" class="group mx-auto flex max-w-5xl items-center gap-3.5" aria-label="Start a new ComposerAI chat">
                <div class="relative flex h-10 w-10 items-center justify-center rounded-xl bg-gradient-to-br from-slate-900 to-slate-800 shadow-lg shadow-slate-900/25 ring-1 ring-slate-900/10 transition-transform group-hover:scale-[1.03]">
                    <svg class="h-5 w-5 text-white" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                        <path d="M3 8L10.89 13.26C11.2187 13.4793 11.6049 13.5963 12 13.5963C12.3951 13.5963 12.7813 13.4793 13.11 13.26L21 8M5 19H19C19.5304 19 20.0391 18.7893 20.4142 18.4142C20.7893 18.0391 21 17.5304 21 17V7C21 6.46957 20.7893 5.96086 20.4142 5.58579C20.0391 5.21071 19.5304 5 19 5H5C4.46957 5 3.96086 5.21071 3.58579 5.58579C3.21071 5.96086 3 6.46957 3 7V17C3 17.5304 3.21071 18.0391 3.58579 18.4142C3.96086 18.7893 4.46957 19 5 19Z" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                        <circle cx="17" cy="7" r="2.5" fill="#10b981" stroke="white" stroke-width="1.5"/>
                    </svg>
                    <div class="pointer-events-none absolute -inset-0.5 -z-10 rounded-xl bg-gradient-to-br from-slate-900 to-slate-800 opacity-0 blur-sm transition group-hover:opacity-60"></div>
                </div>
                <div class="flex flex-col">
                    <span class="text-sm font-bold tracking-tight text-slate-900">ComposerAI</span>
                    <span class="text-[11px] font-medium tracking-wide text-slate-500">Email Intelligence Platform</span>
                </div>
            </a>
        </nav>

        <main class="flex-1 flex">
            <div class="mx-auto flex max-w-5xl flex-1 flex-col px-4 pb-6 pt-6 sm:px-6 lg:px-8">
                <section class="chat-shell flex-1 flex flex-col">
                    <div id="messages"
                        class="flex flex-1 flex-col gap-2.5 px-4 py-4 overflow-y-auto bg-slate-50 sm:px-5 sm:py-5" style="position: relative; z-index: 10;">
                        <div class="message-block w-full">
                            <div class="assistant-surface">
                                <div class="chat-markdown">
                                    <p>Hello! I'm ComposerAI. Upload a file using the icon below and I'll help you analyze and discuss it.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Email Data Table Section -->
                    <div id="email-results-section" class="hidden border-t border-slate-200 bg-white/60 backdrop-blur-sm" style="position: relative; z-index: 1;">
                        <div class="px-4 py-3 sm:px-5 flex items-center justify-between border-b border-slate-200/50">
                            <h3 class="text-lg font-semibold text-slate-800">Email Search Results</h3>
                            <button id="close-email-results" class="text-slate-400 hover:text-slate-600 transition-colors">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                </svg>
                            </button>
                        </div>
                        <div class="px-4 py-4 sm:px-5">
                            <div id="email-data-table-container">
                                <!-- Email Data Table will be rendered here -->
                            </div>
                        </div>
                    </div>

                    <div class="chat-input border-t border-slate-200 px-4 py-4 sm:px-5">
                        <div id="uploadStatus" class="upload-status hidden"></div>
                        <div class="mb-3 flex flex-wrap items-center gap-3 text-xs sm:text-sm text-slate-600">
                            <div id="thinkingDropdown">
                                <button id="thinkingMenuButton" type="button" aria-haspopup="listbox" aria-expanded="false"
                                    class="inline-flex items-center justify-between gap-2 rounded-xl border border-slate-300 bg-white px-3 py-1 font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50">
                                    <span id="thinkingMenuLabel">Thinking: Off</span>
                                    <svg class="h-3 w-3 text-slate-500 transition-transform" viewBox="0 0 20 20"
                                        fill="currentColor">
                                        <path fill-rule="evenodd"
                                            d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z"
                                            clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <button id="jsonToggleButton" type="button"
                                class="rounded-xl border border-slate-300 bg-white px-3 py-1 font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50">JSON
                                Output: Off</button>
                            <div id="thinkingMenu"
                                class="thinking-dropdown-menu fixed z-[9999] w-64 rounded-xl border border-slate-200 bg-white p-1 shadow-xl ring-1 ring-black/5 hidden"
                                aria-labelledby="thinkingMenuButton">
                                <div role="menu">
                                    <button type="button" role="menuitem" data-value="off"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm font-medium text-slate-700 hover:bg-slate-50">Off</button>
                                    <div class="my-1 border-t border-slate-200"></div>
                                    <button type="button" role="menuitem" data-value="minimal"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Minimal</button>
                                    <button type="button" role="menuitem" data-value="low"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Low</button>
                                    <button type="button" role="menuitem" data-value="medium"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">Medium</button>
                                    <button type="button" role="menuitem" data-value="high"
                                        class="w-full rounded-lg px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50">High</button>
                                </div>
                            </div>
                            <span id="thinkingStatus" class="hidden text-slate-500"></span>
                        </div>
                        
                        <!-- Test Email Data Table Button -->
                        <div class="mb-3">
                            <button id="test-email-table" type="button" 
                                class="inline-flex items-center gap-2 rounded-xl border border-emerald-300 bg-emerald-50 px-3 py-1.5 text-xs font-semibold text-emerald-700 shadow-sm transition hover:bg-emerald-100">
                                <svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M3 6h18M3 12h18M3 18h18"/>
                                </svg>
                                Test shadcn/ui Data Table
                            </button>
                        </div>
                        
                        <div class="flex items-center gap-3">
                            <label id="inlineUploadButton"
                                class="flex h-11 w-11 cursor-pointer items-center justify-center rounded-2xl border border-slate-300 bg-white text-slate-600 shadow-sm transition hover:border-slate-400 hover:text-slate-900 focus-within:outline-none focus-within:ring-2 focus-within:ring-slate-200"
                                title="Upload email or file for context" aria-label="Upload email or file for context">
                                <svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6"
                                    stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                    <path d="M4 12l1.5 1.5a2 2 0 002.828 0L12 9.828a2 2 0 012.828 0L20 15" />
                                    <path d="M3 7l9-4 9 4" />
                                    <path d="M21 10v8a2 2 0 01-2 2H5a2 2 0 01-2-2v-8" />
                                </svg>
                                <input type="file" id="inlineFileInput" class="sr-only" accept=".eml,.msg,.txt,.html,.pdf,.doc,.docx" />
                            </label>
                            <textarea id="messageInput"
                                class="flex-1 resize-none rounded-2xl border border-slate-300 px-4 py-3 text-sm focus:border-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-200"
                                placeholder="Type your message about the email..." rows="1" disabled></textarea>
                            <button id="sendButton"
                                class="flex h-10 w-10 items-center justify-center rounded-full bg-slate-900 text-white transition-all hover:bg-slate-700 disabled:bg-slate-300 disabled:cursor-not-allowed"
                                disabled>
                                <span class="text-xl">&rarr;</span>
                            </button>
                        </div>
                    </div>
                </section>
            </div>
        </main>

        <script src="/js/email-list-component.js"></script>
        <script src="/js/email-data-table.js"></script>
        <script th:inline="javascript">
            // Auto-generated from backend Java enums - single source of truth
            // See: GlobalModelAttributes.java â†’ SseEventType.java, ReasoningStreamAdapter.Phase
            const SSE_EVENTS = /*[[${sseEvents}]]*/ {};
            Object.freeze(SSE_EVENTS);

            const REASONING_PHASES = /*[[${reasoningPhases}]]*/ {};
            Object.freeze(REASONING_PHASES);

            const UI_NONCE = /*[[${uiNonce}]]*/ null;

            class SSEEventRouter {
                constructor() {
                    this.handlers = new Map();
                }

                on(eventType, handler) {
                    if (typeof handler === 'function') {
                        this.handlers.set(eventType, handler);
                    }
                    return this;
                }

                route(eventType, data) {
                    const handler = this.handlers.get(eventType);
                    if (handler) handler(data);
                }
            }

            class ComposerAIChat {
                constructor() {
                    this.messages = document.getElementById('messages');
                    this.messageInput = document.getElementById('messageInput');
                    this.sendButton = document.getElementById('sendButton');
                    this.fileDropArea = document.getElementById('fileDropArea');
                    this.fileInput = document.getElementById('fileInput') || document.getElementById('inlineFileInput');
                    this.uploadStatus = document.getElementById('uploadStatus');
                    this.currentEmailContext = null;
                    this.conversationId = null;
                    this.activeStreamController = null;
                    this.isStreaming = false;
                    this.streamState = { thinking: { active: false, phase: 'idle', lastType: null, message: null } };
                    this.thinkingStatus = document.getElementById('thinkingStatus');
                    this.thinkingEnabled = false;
                    this.thinkingLevel = 'medium';
                    this.jsonToggleButton = document.getElementById('jsonToggleButton');
                    this.jsonOutput = false;
                    this.jsonPreClass = 'w-full whitespace-pre-wrap font-mono text-sm leading-relaxed bg-slate-900/90 text-slate-100 rounded-2xl border border-slate-800 p-4 shadow-ultra overflow-x-auto';
                    this.previewCounter = 0;
                    this.streamTimeoutMs = 120000; // Default 2 minutes, updated from server
                    this.maxEmailContextChars = 20000;
                    this.defaultMaxResults = 5;
                    this.insightsTrigger = '__INSIGHTS_TRIGGER__';
                    
                    // Email Data Table components
                    this.emailDataTable = null;
                    this.emailResultsSection = document.getElementById('email-results-section');
                    this.closeEmailResultsBtn = document.getElementById('close-email-results');
                    
                    this.applyMarkdownEnhancements = this.applyMarkdownEnhancements.bind(this);
                    this.initializeEventListeners();
                    this.applyMarkdownEnhancements(this.messages);
                }

                initializeEventListeners() {
                    this.sendButton?.addEventListener('click', () => this.sendMessage());
                    this.messageInput?.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });

                    if (this.fileInput && window.ComposerAI?.FileUploadHandler) {
                        new window.ComposerAI.FileUploadHandler({
                            dropArea: this.fileDropArea || document.getElementById('inlineUploadButton'),
                            fileInput: this.fileInput,
                            onFileSelected: (file) => this.handleFileUpload(file),
                            validExtensions: ['.eml', '.msg', '.txt']
                        });
                    }

                    this.initializeThinkingDropdown();
                    this.initializeJsonToggle();
                    this.initializeEmailTable();
                    this.updateThinkingControls();
                    this.resetReasoningState();
                }

                initializeThinkingDropdown() {
                    const btn = document.getElementById('thinkingMenuButton');
                    const menu = document.getElementById('thinkingMenu');
                    const label = document.getElementById('thinkingMenuLabel');
                    if (!btn || !menu) return;

                    const setOpen = (open) => {
                        if (open) {
                            const rect = btn.getBoundingClientRect();
                            const spaceBelow = window.innerHeight - rect.bottom;
                            const menuHeight = 240;
                            if (spaceBelow >= menuHeight || spaceBelow > rect.top) {
                                menu.style.top = rect.bottom + 8 + 'px';
                                menu.style.bottom = 'auto';
                            } else {
                                menu.style.bottom = window.innerHeight - rect.top + 8 + 'px';
                                menu.style.top = 'auto';
                            }
                            menu.style.left = rect.left + 'px';
                            menu.classList.remove('hidden');
                        } else {
                            menu.classList.add('hidden');
                        }
                        btn.setAttribute('aria-expanded', String(open));
                        btn.querySelector('svg').style.transform = open ? 'rotate(180deg)' : 'rotate(0)';
                    };

                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        setOpen(btn.getAttribute('aria-expanded') !== 'true');
                    });
                    document.addEventListener('click', (e) => {
                        if (!menu.contains(e.target) && !btn.contains(e.target)) setOpen(false);
                    });
                    window.addEventListener('resize', () => {
                        if (btn.getAttribute('aria-expanded') === 'true') setOpen(true);
                    });

                    menu.querySelectorAll('button[data-value]').forEach(opt => {
                        opt.addEventListener('click', () => {
                            this.updateThinkingMode(opt.getAttribute('data-value'));
                            menu.querySelectorAll('button').forEach(b => b.classList.remove('bg-slate-100'));
                            opt.classList.add('bg-slate-100');
                            setOpen(false);
                        });
                    });

                    this.refreshThinkingMenuLabel = () => {
                        if (label) label.textContent = this.thinkingEnabled ?
                            'Thinking: ' + this.thinkingLevel.charAt(0).toUpperCase() + this.thinkingLevel.slice(1) :
                            'Thinking: Off';
                    };
                    this.refreshThinkingMenuLabel();
                }

                initializeJsonToggle() {
                    if (!this.jsonToggleButton) return;
                    this.jsonToggleButton.addEventListener('click', () => {
                        this.jsonOutput = !this.jsonOutput;
                        this.updateJsonToggleButton();
                        if (!this.thinkingEnabled) {
                            this.resetReasoningState();
                        }
                    });
                    this.updateJsonToggleButton();
                }

                updateJsonToggleState() {
                    if (!this.jsonToggleButton) return;
                    this.updateJsonToggleButton();
                }

                updateJsonToggleButton() {
                    if (!this.jsonToggleButton) return;
                    const isOn = !!this.jsonOutput;
                    this.jsonToggleButton.textContent = isOn ? 'JSON Output: On' : 'JSON Output: Off';
                    const add = (cls) => this.jsonToggleButton.classList.add(cls);
                    const remove = (cls) => this.jsonToggleButton.classList.remove(cls);
                    if (isOn) {
                        add('bg-slate-900');
                        add('text-white');
                        add('border-slate-900');
                        remove('bg-white');
                        remove('text-slate-700');
                        remove('border-slate-300');
                    } else {
                        remove('bg-slate-900');
                        remove('text-white');
                        remove('border-slate-900');
                        add('bg-white');
                        add('text-slate-700');
                        add('border-slate-300');
                    }
                }

                async handleFileUpload(file) {
                    this.showUploadStatus('<div class="upload-status upload-status--info">Uploading and parsing file...</div>');

                    try {
                        const result = await window.ComposerAI.parseEmailFile(file, UI_NONCE);
                        if (!result.contextId) {
                            throw new Error('Server did not provide a contextId for the uploaded file');
                        }
                        this.currentEmailContext = result;
                        this.showUploadStatus('<div class="upload-status upload-status--success">Context uploaded and parsed successfully!</div>');
                        this.enableChat();
                        this.addEmailContextMessage(result);
                    } catch (error) {
                        this.showUploadStatus('<div class="upload-status upload-status--error">Failed to upload file: ' + window.ComposerAI.escapeHtml(String(error?.message || 'Unknown error')) + '</div>');
                    }
                    this.enableChat();
                }

                showUploadStatus(html) {
                    if (!this.uploadStatus) return;
                    this.uploadStatus.innerHTML = html;
                    this.uploadStatus.classList.toggle('hidden', !html);
                }

                getFriendlyFileType(filename) {
                    const lower = filename.toLowerCase();
                    if (lower.endsWith('.eml')) return 'Email (.eml)';
                    if (lower.endsWith('.msg')) return 'Outlook Message (.msg)';
                    if (lower.endsWith('.txt')) return 'Text File (.txt)';
                    if (lower.endsWith('.html') || lower.endsWith('.htm')) return 'HTML File';
                    return 'Unknown';
                }

                updateThinkingMode(value) {
                    const v = (value || 'off').toLowerCase();
                    this.thinkingEnabled = v !== 'off';
                    if (this.thinkingEnabled) this.thinkingLevel = v;
                    this.updateThinkingControls();
                    this.refreshThinkingMenuLabel();
                    if (v === 'off') this.resetReasoningState();
                }

                updateThinkingControls() {
                    const enabled = !this.messageInput?.disabled;
                    this.refreshThinkingMenuLabel();
                    if (this.thinkingStatus) {
                        this.thinkingStatus.classList.toggle('hidden', !enabled);
                        if (enabled) this.renderThinkingStatus();
                    }
                    this.updateJsonToggleState();
                }

                enableChat() {
                    this.messageInput.disabled = false;
                    this.sendButton.disabled = false;
                    this.messageInput.placeholder = "Ask me anything about this email...";
                    this.updateThinkingControls();
                }

                addEmailContextMessage(emailData) {
                    const subject = window.ComposerAI.escapeHtml(emailData.subject || 'No subject');
                    const from = window.ComposerAI.escapeHtml(emailData.from || 'Unknown sender');
                    const dateLabel = window.ComposerAI.escapeHtml(emailData.date || 'Unknown date');
                    const iso = (emailData.dateIso || '').trim();
                    const previewMd = (emailData.parsedMarkdown || emailData.parsedPlain || '').trim();
                    const previewId = 'email-preview-' + (++this.previewCounter);

                    // Create email card with dropdown menu using our component
                    const emailCard = document.createElement('div');
                    emailCard.className = 'email-card';
                    emailCard.innerHTML = `
                        <div class="email-card-header">
                            <div class="email-icon">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M2.25 6.75A3.75 3.75 0 016 3h12a3.75 3.75 0 013.75 3.75v10.5A3.75 3.75 0 0118 21H6a3.75 3.75 0 01-3.75-3.75V6.75zm3.82-.456a.75.75 0 00-.82 1.26l6 3.9a.75.75 0 00.82 0l6-3.9a.75.75 0 00-.82-1.26L12 9.694 6.07 6.294z"/>
                                </svg>
                            </div>
                            <div class="email-info">
                                <div class="email-subject">${subject}</div>
                                <div class="email-meta">
                                    <span class="email-sender">${from}</span>
                                    <span class="email-date" data-original-label="${dateLabel}" ${iso ? 'data-date-iso="' + window.ComposerAI.escapeHtml(iso) + '"' : ''}>${dateLabel}</span>
                                </div>
                            </div>
                            <div class="email-actions">
                                <button type="button" class="email-expand-btn" data-email-id="${previewId}" aria-label="Expand email">
                                    <svg class="email-expand-icon" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.24 4.24a.75.75 0 01-1.06 0L5.21 8.29a.75.75 0 01.02-1.08z" clip-rule="evenodd"/>
                                    </svg>
                                </button>
                                <div class="email-dropdown">
                                    <button type="button" class="email-dropdown-trigger" aria-label="Email actions">
                                        <svg viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
                                        </svg>
                                    </button>
                                    <div class="email-dropdown-menu" style="display: none;">
                                        <div class="email-dropdown-item" data-action="view-full" onclick="handleEmailAction('${previewId}', 'view-full')">
                                            View Full Content
                                        </div>
                                        <div class="email-dropdown-item" data-action="copy" onclick="handleEmailAction('${previewId}', 'copy')">
                                            Copy to Clipboard
                                        </div>
                                        <div class="email-dropdown-item" data-action="insights" onclick="handleEmailAction('${previewId}', 'insights')">
                                            Get AI Insights
                                        </div>
                                        <div class="email-dropdown-item" data-action="download" onclick="handleEmailAction('${previewId}', 'download')">
                                            Download
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="email-preview" id="${previewId}" style="display: none;">
                            <div class="chat-markdown">
                                ${previewMd.length > 0 ? window.ComposerAI.renderMarkdown(previewMd) : '<p class="text-xs italic text-slate-500">Email preview unavailable.</p>'}
                            </div>
                        </div>
                    `;

                    // Store email data for dropdown actions
                    emailCard.dataset.emailSubject = subject;
                    emailCard.dataset.emailContent = previewMd;

                    // Expand/collapse functionality
                    const expandBtn = emailCard.querySelector('.email-expand-btn');
                    const preview = emailCard.querySelector('.email-preview');
                    const expandIcon = emailCard.querySelector('.email-expand-icon');
                    
                    expandBtn.addEventListener('click', () => {
                        const isExpanded = preview.style.display !== 'none';
                        preview.style.display = isExpanded ? 'none' : 'block';
                        emailCard.classList.toggle('expanded', !isExpanded);
                        expandIcon.style.transform = isExpanded ? 'rotate(0deg)' : 'rotate(180deg)';
                    });

                    // Dropdown functionality
                    const dropdownTrigger = emailCard.querySelector('.email-dropdown-trigger');
                    const dropdownMenu = emailCard.querySelector('.email-dropdown-menu');
                    
                    dropdownTrigger.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isVisible = dropdownMenu.style.display !== 'none';
                        // Close all other dropdowns
                        document.querySelectorAll('.email-dropdown-menu').forEach(menu => menu.style.display = 'none');
                        dropdownMenu.style.display = isVisible ? 'none' : 'block';
                    });

                    // Close dropdown when clicking outside
                    document.addEventListener('click', () => {
                        dropdownMenu.style.display = 'none';
                    });

                    const wrapper = document.createElement('div');
                    wrapper.className = 'message-block w-full';
                    const surface = document.createElement('div');
                    surface.className = 'assistant-surface';
                    surface.appendChild(emailCard);
                    wrapper.appendChild(surface);
                    this.messages.appendChild(wrapper);
                    this.localizeDate(emailCard.querySelector('.email-date'));
                    this.applyMarkdownEnhancements(surface);
                    this.messages.scrollTop = this.messages.scrollHeight;
                }

                handleEmailAction(emailId, action) {
                    const emailCard = document.querySelector(`[data-email-id="${emailId}"]`)?.closest('.email-card');
                    if (!emailCard) return;

                    const subject = emailCard.dataset.emailSubject || 'Email';
                    const content = emailCard.dataset.emailContent || '';

                    switch(action) {
                        case 'view-full':
                            alert(`Full Content:\n\n${content}`);
                            break;
                        case 'copy':
                            navigator.clipboard.writeText(content).then(() => {
                                this.showUploadStatus('Email content copied to clipboard!', 'success');
                            });
                            break;
                        case 'insights':
                            this.triggerInsights();
                            break;
                        case 'download':
                            const blob = new Blob([content], { type: 'text/plain' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = subject + '.txt';
                            a.click();
                            URL.revokeObjectURL(url);
                            this.showUploadStatus('Email downloaded!', 'success');
                            break;
                    }
                }

                buildChatPayload(message, jsonOutput) {
                    const contextId = this.currentEmailContext?.contextId || null;
                    const payload = {
                        message,
                        conversationId: this.conversationId,
                        maxResults: this.defaultMaxResults,
                        contextId,
                        thinkingEnabled: this.thinkingEnabled,
                        thinkingLevel: this.thinkingEnabled ? this.thinkingLevel : null,
                        jsonOutput: !!jsonOutput
                    };

                    const rawContext = this.currentEmailContext?.contextForAI;
                    if (contextId && rawContext) {
                        payload.emailContext = rawContext.length > this.maxEmailContextChars
                            ? rawContext.slice(0, this.maxEmailContextChars)
                            : rawContext;
                    }

                    return payload;
                }

                async sendMessage() {
                    const message = this.messageInput.value.trim();
                    if (!message || this.isStreaming) return;

                    if (this.activeStreamController) {
                        try { this.activeStreamController.abort(); } catch (_) { }
                    }
                    this.addMessage(message, 'user');
                    this.messageInput.value = '';

                    const isJsonMode = this.jsonOutput;
                    const assistantDiv = this.addMessage('', 'assistant');
                    if (isJsonMode) {
                        assistantDiv.innerHTML = '<div class="phase-badge phase-streaming">Preparing JSON...</div><pre class="' + this.jsonPreClass + '"></pre>';
                    } else {
                        assistantDiv.innerHTML = '<div class="assistant-thinking relative"><div class="phase-badge phase-thinking">' + (this.thinkingEnabled ? 'Thinking...' : 'Parsing your email...') + '</div><div class="thinking-skeleton rounded-xl border border-slate-200 bg-slate-50/80 p-3"><div class="thinking-line"></div><div class="thinking-line"></div><div class="thinking-line short"></div><div class="thinking-cursor-bar"></div></div></div>';
                    }

                    const payload = this.buildChatPayload(message, isJsonMode);

                    this.messageInput.disabled = true;
                    this.sendButton.disabled = true;
                    this.updateThinkingControls();
                    this.isStreaming = true;
                    this.activeStreamController = new AbortController();
                    const timeoutId = setTimeout(() => {
                        try { this.activeStreamController?.abort(); } catch (_) { }
                    }, this.streamTimeoutMs);

                    try {
                        await this.streamResponse(payload, assistantDiv, this.activeStreamController.signal);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Request timed out. Please try again.');
                        } else {
                            try {
                                await this.sendChatRequest(payload, assistantDiv);
                            } catch (fallbackError) {
                                assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Sorry, I encountered an error. Please try again.');
                            }
                        }
                    } finally {
                        clearTimeout(timeoutId);
                        this.isStreaming = false;
                        this.activeStreamController = null;
                        this.messageInput.disabled = false;
                        this.sendButton.disabled = false;
                        this.updateThinkingControls();
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                async triggerInsights() {
                    if (this.isStreaming) return;

                    if (this.activeStreamController) {
                        try { this.activeStreamController.abort(); } catch (_) { }
                    }

                    // Skip user message bubble - go straight to assistant response
                    const assistantDiv = this.addMessage('', 'assistant');
                    assistantDiv.innerHTML = '<div class="assistant-thinking relative"><div class="phase-badge phase-thinking">Analyzing email...</div><div class="thinking-skeleton rounded-xl border border-slate-200 bg-slate-50/80 p-3"><div class="thinking-line"></div><div class="thinking-line"></div><div class="thinking-line short"></div><div class="thinking-cursor-bar"></div></div></div>';

                    const payload = this.buildChatPayload(this.insightsTrigger, false);

                    this.messageInput.disabled = true;
                    this.sendButton.disabled = true;
                    this.updateThinkingControls();
                    this.isStreaming = true;
                    this.activeStreamController = new AbortController();
                    const timeoutId = setTimeout(() => {
                        try { this.activeStreamController?.abort(); } catch (_) { }
                    }, this.streamTimeoutMs);

                    try {
                        // Call insights-specific endpoint
                        await this.streamInsightsResponse(payload, assistantDiv, this.activeStreamController.signal);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Request timed out. Please try again.');
                        } else {
                            assistantDiv.innerHTML = window.ComposerAI.renderMarkdown('Sorry, I encountered an error. Please try again.');
                        }
                    } finally {
                        clearTimeout(timeoutId);
                        this.isStreaming = false;
                        this.activeStreamController = null;
                        this.messageInput.disabled = false;
                        this.sendButton.disabled = false;
                        this.updateThinkingControls();
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                async streamInsightsResponse(payload, targetDiv, signal) {
                    // Call insights endpoint - backend controls the prompt
                    const response = await fetch('/api/chat/insights/stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-UI-Request': UI_NONCE },
                        body: JSON.stringify(payload),
                        signal
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);

                    const timeoutHint = response.headers.get('X-Stream-Timeout-Hint');
                    if (timeoutHint) {
                        const parsed = parseInt(timeoutHint, 10);
                        if (!isNaN(parsed) && parsed > 0) this.streamTimeoutMs = parsed;
                    }

                    // Use same streaming logic as regular chat
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    const isJsonMode = false; // Insights always uses normal mode
                    let html = '';
                    let buffer = '';
                    let firstToken = true;
                    let conversationIdFromServer = null;
                    let currentEvent = null;
                    let currentEventData = [];
                    let streamFinished = false;

                    const finalizeStream = () => {
                        if (html) {
                            targetDiv.innerHTML = html;
                            this.applyMarkdownEnhancements(targetDiv);
                        } else {
                            targetDiv.innerHTML = window.ComposerAI.renderMarkdown("I don't have a response to that.");
                            this.applyMarkdownEnhancements(targetDiv);
                        }
                        this.conversationId = conversationIdFromServer || payload.conversationId || this.conversationId;
                        this.resetReasoningState();
                        streamFinished = true;
                    };

                    const router = new SSEEventRouter()
                        .on(SSE_EVENTS.METADATA, (raw) => {
                            if (!raw) return;
                            try {
                                const metadata = JSON.parse(raw);
                                if (metadata.conversationId) conversationIdFromServer = metadata.conversationId;
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse metadata event', err);
                            }
                        })
                        .on(SSE_EVENTS.RENDERED_HTML, (chunk) => {
                            if (chunk == null) return;
                            if (firstToken) {
                                targetDiv.innerHTML = '<div class="phase-badge phase-streaming">Streaming...</div>';
                                firstToken = false;
                            }
                            html += chunk || '';
                            targetDiv.innerHTML = html + '<span class="streaming-cursor">|</span>';
                            this.scrollIfAtBottom();
                        })
                        .on(SSE_EVENTS.REASONING, (raw) => {
                            if (!raw) return;
                            try {
                                this.updateStreamState(JSON.parse(raw));
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse reasoning payload', err);
                            }
                        })
                        .on(SSE_EVENTS.ERROR, (message) => {
                            throw new Error(message || 'Stream error occurred');
                        })
                        .on(SSE_EVENTS.DONE, () => finalizeStream());

                    while (!streamFinished) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            const cleanedLine = line.endsWith('\r') ? line.slice(0, -1) : line;

                            if (cleanedLine.startsWith('event:')) {
                                if (currentEvent && currentEventData.length) {
                                    router.route(currentEvent, currentEventData.join('\n'));
                                } else if (currentEvent && currentEventData.length === 0) {
                                    router.route(currentEvent, '');
                                }
                                currentEvent = cleanedLine.substring(6).trim();
                                currentEventData = [];
                                continue;
                            }

                            if (cleanedLine.startsWith('data:')) {
                                const value = cleanedLine.length >= 6 && cleanedLine.charAt(5) === ' '
                                    ? cleanedLine.substring(6)
                                    : cleanedLine.substring(5);
                                currentEventData.push(value);
                                continue;
                            }

                            if (cleanedLine === '') {
                                if (currentEvent) {
                                    const payload = currentEventData.length > 0
                                        ? currentEventData.join('\n')
                                        : '';
                                    router.route(currentEvent, payload);
                                }
                                currentEvent = null;
                                currentEventData = [];
                                if (streamFinished) break;
                                continue;
                            }
                        }
                    }

                    if (!streamFinished) {
                        if (currentEvent) {
                            const payload = currentEventData.length > 1
                                ? currentEventData.join('\n')
                                : (currentEventData[0] ?? '');
                            router.route(currentEvent, payload);
                        }
                        finalizeStream();
                    }
                }

                async sendChatRequest(payload, targetDiv) {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-UI-Request': UI_NONCE },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    const result = await response.json();
                    const isJsonMode = !!payload.jsonOutput;
                    const html = (result.sanitizedHtml || result.sanitizedHTML || result.renderedHtml || result.renderedHTML || '').trim();
                    const raw = (result.rawMarkdown || result.response || result.message || '').trim();
                    if (isJsonMode) {
                        const pre = document.createElement('pre');
                        pre.className = this.jsonPreClass;
                        if (raw) {
                            try {
                                const parsed = JSON.parse(raw);
                                pre.textContent = JSON.stringify(parsed, null, 2);
                            } catch (_) {
                                pre.textContent = raw;
                            }
                        } else {
                            pre.textContent = '{ }';
                        }
                        targetDiv.innerHTML = '';
                        targetDiv.appendChild(pre);
                    } else {
                        if (html) {
                            targetDiv.innerHTML = html;
                            this.applyMarkdownEnhancements(targetDiv);
                        } else {
                            targetDiv.innerHTML = window.ComposerAI.renderMarkdown(raw || 'I received your message about the email.');
                            this.applyMarkdownEnhancements(targetDiv);
                        }
                    }
                    if (result.conversationId) this.conversationId = result.conversationId;
                }

                async streamResponse(payload, targetDiv, signal) {
                    const response = await fetch('/api/chat/stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-UI-Request': UI_NONCE },
                        body: JSON.stringify(payload),
                        signal
                    });
                    if (!response.ok) throw new Error('HTTP ' + response.status);

                    const timeoutHint = response.headers.get('X-Stream-Timeout-Hint');
                    if (timeoutHint) {
                        const parsed = parseInt(timeoutHint, 10);
                        if (!isNaN(parsed) && parsed > 0) this.streamTimeoutMs = parsed;
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let isJsonMode = !!payload.jsonOutput;
                    let html = '';
                    let jsonBuffer = '';
                    let buffer = '';
                    let firstToken = true;
                    let jsonPre = null;
                    let conversationIdFromServer = null;
                    let currentEvent = null;
                    let currentEventData = [];
                    let streamFinished = false;

                    const finalizeStream = () => {
                        if (isJsonMode) {
                            if (jsonPre) {
                                try {
                                    const parsed = JSON.parse(jsonBuffer);
                                    jsonPre.textContent = JSON.stringify(parsed, null, 2);
                                } catch (_) {
                                    jsonPre.textContent = jsonBuffer || '{ }';
                                }
                            } else if (jsonBuffer) {
                                const pre = document.createElement('pre');
                                pre.className = this.jsonPreClass;
                                try {
                                    const parsed = JSON.parse(jsonBuffer);
                                    pre.textContent = JSON.stringify(parsed, null, 2);
                                } catch (_) {
                                    pre.textContent = jsonBuffer;
                                }
                                targetDiv.innerHTML = '';
                                targetDiv.appendChild(pre);
                            } else {
                                targetDiv.innerHTML = window.ComposerAI.renderMarkdown('No response received.');
                            }
                        } else {
                            if (html) {
                                targetDiv.innerHTML = html;
                                this.applyMarkdownEnhancements(targetDiv);
                            } else {
                            targetDiv.innerHTML = window.ComposerAI.renderMarkdown("I don't have a response to that.");
                            this.applyMarkdownEnhancements(targetDiv);
                            }
                        }
                        this.conversationId = conversationIdFromServer || payload.conversationId || this.conversationId;
                        this.resetReasoningState();
                        streamFinished = true;
                    };

                    const router = new SSEEventRouter()
                        .on(SSE_EVENTS.METADATA, (raw) => {
                            if (!raw) return;
                            try {
                                const metadata = JSON.parse(raw);
                                if (metadata.conversationId) conversationIdFromServer = metadata.conversationId;
                                if (metadata.jsonOutput !== undefined) {
                                    isJsonMode = Boolean(metadata.jsonOutput);
                                }
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse metadata event', err);
                            }
                        })
                        .on(SSE_EVENTS.RENDERED_HTML, (chunk) => {
                            if (chunk == null || isJsonMode) return;
                            if (firstToken) {
                                targetDiv.innerHTML = '<div class="phase-badge phase-streaming">Streaming...</div>';
                                firstToken = false;
                            }
                            html += chunk || '';
                            targetDiv.innerHTML = html + '<span class="streaming-cursor">|</span>';
                            this.scrollIfAtBottom();
                        })
                        .on(SSE_EVENTS.RAW_JSON, (chunk) => {
                            if (chunk == null || !isJsonMode) return;
                            jsonBuffer += chunk;
                            if (firstToken) {
                                targetDiv.innerHTML = '<div class="phase-badge phase-streaming">Streaming JSON...</div><pre class="' + this.jsonPreClass + '"></pre>';
                                jsonPre = targetDiv.querySelector('pre');
                                firstToken = false;
                            }
                            if (jsonPre) {
                                jsonPre.textContent = jsonBuffer;
                            }
                            this.scrollIfAtBottom();
                        })
                        .on(SSE_EVENTS.REASONING, (raw) => {
                            if (!raw) return;
                            try {
                                this.updateStreamState(JSON.parse(raw));
                            } catch (err) {
                                console.warn('ComposerAI: Failed to parse reasoning payload', err);
                            }
                        })
                        .on(SSE_EVENTS.ERROR, (message) => {
                            throw new Error(message || 'Stream error occurred');
                        })
                        .on(SSE_EVENTS.DONE, () => finalizeStream());

                    while (!streamFinished) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        // SSE spec allows multiple data: lines per event; accumulate until blank line terminator.
                        for (const line of lines) {
                            const cleanedLine = line.endsWith('\r') ? line.slice(0, -1) : line;

                            if (cleanedLine.startsWith('event:')) {
                                if (currentEvent && currentEventData.length) {
                                    router.route(currentEvent, currentEventData.join('\n'));
                                } else if (currentEvent && currentEventData.length === 0) {
                                    router.route(currentEvent, '');
                                }
                                currentEvent = cleanedLine.substring(6).trim();
                                currentEventData = [];
                                continue;
                            }

                            if (cleanedLine.startsWith('data:')) {
                                const value = cleanedLine.length >= 6 && cleanedLine.charAt(5) === ' '
                                    ? cleanedLine.substring(6)
                                    : cleanedLine.substring(5);
                                currentEventData.push(value);
                                continue;
                            }

                            if (cleanedLine === '') {
                                if (currentEvent) {
                                    const payload = currentEventData.length > 0
                                        ? currentEventData.join('\n')
                                        : '';
                                    router.route(currentEvent, payload);
                                }
                                currentEvent = null;
                                currentEventData = [];
                                if (streamFinished) break;
                                continue;
                            }
                        }
                    }

                    if (!streamFinished) {
                        if (currentEvent) {
                            const payload = currentEventData.length > 1
                                ? currentEventData.join('\n')
                                : (currentEventData[0] ?? '');
                            router.route(currentEvent, payload);
                        }
                        finalizeStream();
                    }
                }

                scrollIfAtBottom() {
                    if (this.messages.scrollTop + this.messages.clientHeight >= this.messages.scrollHeight - 50) {
                        this.messages.scrollTop = this.messages.scrollHeight;
                    }
                }

                localizeDate(elem) {
                    if (!elem) return;
                    const iso = elem.getAttribute('data-date-iso');
                    const original = elem.getAttribute('data-original-label') || '';
                    if (!iso) {
                        if (!elem.textContent?.trim()) {
                            elem.textContent = original;
                        }
                        return;
                    }
                    try {
                        const localDate = new Date(iso);
                        if (!isNaN(localDate.getTime())) {
                            const formatted = localDate.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
                            elem.textContent = formatted;
                            elem.setAttribute('title', 'Original: ' + original + '\nISO: ' + iso);
                            return;
                        }
                    } catch (_) { }
                    elem.textContent = original;
                }

                addMessage(content, sender) {
                    const div = document.createElement('div');
                    if (sender === 'user') {
                        div.className = 'message-user max-w-[60%] rounded-2xl bg-slate-900 text-white px-4 py-2.5 shadow-sm';
                        div.textContent = content;
                        const wrapper = document.createElement('div');
                        wrapper.className = 'message-block w-full justify-end';
                        wrapper.appendChild(div);
                        this.messages.appendChild(wrapper);
                    } else {
                        const surface = document.createElement('div');
                        surface.className = 'assistant-surface';
                        const markdownContainer = document.createElement('div');
                        markdownContainer.className = 'chat-markdown';
                        if (content?.trim()) {
                            markdownContainer.innerHTML = window.ComposerAI.renderMarkdown(content);
                            this.applyMarkdownEnhancements(markdownContainer);
                        }
                        surface.appendChild(markdownContainer);
                        div.appendChild(surface);
                        const wrapper = document.createElement('div');
                        wrapper.className = 'message-block w-full';
                        wrapper.appendChild(surface);
                        this.messages.appendChild(wrapper);
                        return markdownContainer;
                    }
                    this.messages.scrollTop = this.messages.scrollHeight;
                    return div;
                }

                applyMarkdownEnhancements(root) {
                    if (!root) return;
                    const blocks = (root.classList && root.classList.contains('chat-markdown'))
                        ? [root]
                        : Array.from(root.querySelectorAll('.chat-markdown'));
                    if (blocks.length === 0) return;

                    blocks.forEach(block => {
                        block.querySelectorAll('table').forEach(table => {
                            table.classList.add('chat-table');
                            if (!table.closest('.chat-table-wrapper')) {
                                const wrapper = document.createElement('div');
                                wrapper.className = 'chat-table-wrapper';
                                const parent = table.parentNode;
                                if (parent) {
                                    parent.insertBefore(wrapper, table);
                                    wrapper.appendChild(table);
                                }
                            }
                        });

                        block.querySelectorAll('pre').forEach(pre => {
                            pre.classList.add('chat-code-block');
                        });

                        block.querySelectorAll('code').forEach(code => {
                            if (code.parentElement && code.parentElement.tagName === 'PRE') return;
                            code.classList.add('chat-inline-code');
                        });

                        block.querySelectorAll('blockquote').forEach(quote => {
                            quote.classList.add('chat-blockquote');
                        });
                    });
                }

                updateStreamState(message) {
                    if (!message || !message.type || !message.phase) return;
                    const phase = String(message.phase).toLowerCase();
                    const type = String(message.type).toUpperCase();
                    this.streamState.thinking = { active: true, phase, lastType: type, message };
                    this.renderThinkingStatus(message);
                }

                renderThinkingStatus(message = {}) {
                    if (!this.thinkingStatus) return;
                    const { active } = this.streamState.thinking || {};
                    if (!active) {
                        this.thinkingStatus.textContent = 'Thinking disabled for faster responses.';
                        return;
                    }
                    const label = (message.displayLabel || 'Reasoningâ€¦').trim();
                    this.thinkingStatus.textContent = label;
                }

                resetReasoningState() {
                    this.streamState.thinking = { active: false, phase: 'idle', lastType: null, message: null };
                    if (this.thinkingStatus) {
                        this.thinkingStatus.textContent = 'Thinking disabled for faster responses.';
                    }
                }

                initializeEmailTable() {
                    // Initialize the Email Data Table component
                    if (this.closeEmailResultsBtn) {
                        this.closeEmailResultsBtn.addEventListener('click', () => {
                            this.hideEmailResults();
                        });
                    }
                    
                    // Add test button event listener
                    const testButton = document.getElementById('test-email-table');
                    console.log('Test button element:', testButton);
                    if (testButton) {
                        testButton.addEventListener('click', () => {
                            console.log('Test button clicked!');
                            this.loadSampleEmails();
                        });
                    } else {
                        console.error('Test button not found in DOM');
                    }
                }

                async loadSampleEmails() {
                    console.log('loadSampleEmails called');
                    console.log('UI_NONCE:', UI_NONCE);
                    
                    try {
                        console.log('Fetching sample emails from API...');
                        const response = await fetch('/api/emails/sample-emails', {
                            method: 'GET',
                            headers: { 
                                'Content-Type': 'application/json',
                                'X-UI-Request': UI_NONCE 
                            }
                        });
                        
                        console.log('API response status:', response.status);
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('API error response:', errorText);
                            throw new Error(`HTTP ${response.status}: ${errorText}`);
                        }
                        
                        const data = await response.json();
                        console.log('API data received:', data);
                        
                        if (data.emails) {
                            console.log('Showing email results with', data.emails.length, 'emails');
                            this.showEmailResults(data.emails);
                        } else {
                            console.warn('No emails in response data');
                        }
                        
                    } catch (error) {
                        console.error('Failed to load sample emails:', error);
                        this.showUploadStatus('Failed to load sample emails: ' + error.message, 'error');
                    }
                }

                showEmailResults(emails) {
                    console.log('showEmailResults called with:', emails);
                    
                    if (!emails || emails.length === 0) {
                        console.warn('No emails to display');
                        return;
                    }
                    
                    console.log('Email results section:', this.emailResultsSection);
                    console.log('Showing email results section');
                    
                    // Show the email results section
                    if (this.emailResultsSection) {
                        this.emailResultsSection.classList.remove('hidden');
                    }
                    
                    console.log('Creating/updating EmailDataTable');
                    
                    // Initialize or update the data table
                    if (!this.emailDataTable) {
                        console.log('Creating new EmailDataTable instance');
                        this.emailDataTable = new EmailDataTable('email-data-table-container', {
                            onRowAction: (action, email) => this.handleEmailAction(action, email),
                            showSelection: true,
                            showPagination: true
                        });
                    }
                    
                    console.log('Loading emails into table');
                    // Load the emails into the table
                    this.emailDataTable.loadEmails(emails);
                    
                    console.log('Scrolling to table');
                    // Scroll to show the table
                    this.emailResultsSection.scrollIntoView({ behavior: 'smooth' });
                }

                hideEmailResults() {
                    if (this.emailResultsSection) {
                        this.emailResultsSection.classList.add('hidden');
                    }
                }

                handleEmailAction(action, email) {
                    console.log('Email action:', action, email);
                    
                    switch (action) {
                        case 'view-full':
                            this.viewFullEmail(email);
                            break;
                        case 'copy':
                            this.copyEmailToClipboard(email);
                            break;
                        case 'insights':
                            this.getEmailInsights(email);
                            break;
                        case 'download':
                            this.downloadEmail(email);
                            break;
                        default:
                            console.warn('Unknown email action:', action);
                    }
                }

                viewFullEmail(email) {
                    // Add email content to chat as a message
                    const emailSummary = `**Subject:** ${email.subject}\n**From:** ${email.sender}\n**Date:** ${new Date(email.date).toLocaleString()}\n\n${email.content || 'Full content not available'}`;
                    
                    const messageDiv = this.createMessageDiv(false);
                    messageDiv.innerHTML = window.ComposerAI.renderMarkdown(emailSummary);
                    this.applyMarkdownEnhancements(messageDiv);
                }

                async copyEmailToClipboard(email) {
                    const emailText = `Subject: ${email.subject}\nFrom: ${email.sender}\nDate: ${new Date(email.date).toLocaleString()}\n\n${email.content || 'Content not available'}`;
                    
                    try {
                        await navigator.clipboard.writeText(emailText);
                        this.showUploadStatus('Email copied to clipboard!', 'success');
                    } catch (err) {
                        console.error('Failed to copy email:', err);
                        this.showUploadStatus('Failed to copy email', 'error');
                    }
                }

                async getEmailInsights(email) {
                    if (this.isStreaming) return;
                    
                    try {
                        this.isStreaming = true;
                        this.messageInput.disabled = true;
                        this.sendButton.disabled = true;
                        
                        const insightDiv = this.createMessageDiv(false);
                        insightDiv.innerHTML = '<div class="phase-badge phase-thinking">Getting insights...</div>';
                        
                        const controller = new AbortController();
                        this.activeStreamController = controller;
                        
                        const payload = {
                            message: `${this.insightsTrigger}Please provide insights about this email: Subject: ${email.subject}, From: ${email.sender}`,
                            conversationId: this.conversationId,
                            emailContext: email.content ? email.content.substring(0, this.maxEmailContextChars) : null,
                            thinking: this.thinkingEnabled ? { enabled: true, level: this.thinkingLevel } : { enabled: false }
                        };
                        
                        await this.streamInsightsResponse(payload, insightDiv, controller.signal);
                        
                    } catch (error) {
                        console.error('Error getting email insights:', error);
                        this.showUploadStatus('Failed to get email insights', 'error');
                    } finally {
                        this.isStreaming = false;
                        this.activeStreamController = null;
                        this.messageInput.disabled = false;
                        this.sendButton.disabled = false;
                    }
                }

                downloadEmail(email) {
                    const emailContent = `Subject: ${email.subject}\nFrom: ${email.sender}\nDate: ${new Date(email.date).toLocaleString()}\n\n${email.content || 'Content not available'}`;
                    const blob = new Blob([emailContent], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${email.subject.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            document.addEventListener('DOMContentLoaded', function () {
                try {
                    const chat = new ComposerAIChat();
                    // Make handleEmailAction globally accessible for dropdown menu
                    window.handleEmailAction = (emailId, action) => chat.handleEmailAction(emailId, action);
                } catch (error) {
                    console.error('ComposerAI: Failed to initialize chat interface:', error);
                }
            });
        </script>
    </div>
</body>

</html>
